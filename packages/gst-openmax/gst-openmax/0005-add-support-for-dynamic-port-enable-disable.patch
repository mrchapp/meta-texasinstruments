From 0d27c1903748975b8afeb56e6bcc88e500411762 Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Fri, 13 Nov 2009 09:06:43 -0600
Subject: [PATCH 05/12] add support for dynamic port enable/disable
To: gst_omap4@list.ti.com

Signed-off-by: Rob Clark <rob@ti.com>
---
 omx/gstomx_core.c       |   10 +++++-
 omx/gstomx_port.c       |   19 +++++++---
 tests/cameratest.py     |   91 +++++++++++++++++++++++++++++++++++++++++++++++
 tests/standalone/core.c |    4 +-
 util/async_queue.c      |   30 +++-------------
 util/async_queue.h      |    2 +-
 6 files changed, 122 insertions(+), 34 deletions(-)
 create mode 100755 tests/cameratest.py

diff --git a/omx/gstomx_core.c b/omx/gstomx_core.c
index 52ab799..f631a9a 100644
--- a/omx/gstomx_core.c
+++ b/omx/gstomx_core.c
@@ -277,6 +277,14 @@ g_omx_core_deinit (GOmxCore *core)
     core->imp = NULL;
 }
 
+static void
+port_prepare (GOmxPort *port)
+{
+    /* only allocate buffers if the port is actually enabled: */
+    if (port->enabled)
+        g_omx_port_allocate_buffers (port);
+}
+
 void
 g_omx_core_prepare (GOmxCore *core)
 {
@@ -284,7 +292,7 @@ g_omx_core_prepare (GOmxCore *core)
     change_state (core, OMX_StateIdle);
 
     /* Allocate buffers. */
-    core_for_each_port (core, g_omx_port_allocate_buffers);
+    core_for_each_port (core, port_prepare);
 
     wait_for_state (core, OMX_StateIdle);
     GST_DEBUG_OBJECT (core->object, "end");
diff --git a/omx/gstomx_port.c b/omx/gstomx_port.c
index 49fd19b..6a2fc05 100644
--- a/omx/gstomx_port.c
+++ b/omx/gstomx_port.c
@@ -146,9 +146,6 @@ g_omx_port_allocate_buffers (GOmxPort *port)
     if (port->buffers)
         return;
 
-    if (!port->enabled)
-        return;
-
     DEBUG (port, "begin");
 
 #ifdef USE_OMXTICORE
@@ -249,7 +246,11 @@ g_omx_port_free_buffers (GOmxPort *port)
     {
         OMX_BUFFERHEADERTYPE *omx_buffer;
 
-        omx_buffer = port->buffers[i];
+        /* pop the buffer, to be sure that it has been returned from the
+         * OMX component, to avoid freeing a buffer that the component
+         * is still accessing:
+         */
+        omx_buffer = async_queue_pop_full (port->queue, TRUE, TRUE);
 
         if (omx_buffer)
         {
@@ -262,6 +263,7 @@ g_omx_port_free_buffers (GOmxPort *port)
             }
 #endif
 
+            DEBUG (port, "OMX_FreeBuffer(%p)", omx_buffer);
             OMX_FreeBuffer (port->core->omx_handle, port->port_index, omx_buffer);
             port->buffers[i] = NULL;
         }
@@ -632,7 +634,7 @@ g_omx_port_flush (GOmxPort *port)
          * yet processed in the output_loop.
          */
         OMX_BUFFERHEADERTYPE *omx_buffer;
-        while ((omx_buffer = async_queue_pop_forced (port->queue)))
+        while ((omx_buffer = async_queue_pop_full (port->queue, FALSE, TRUE)))
         {
             omx_buffer->nFilledLen = 0;
             release_buffer (port, omx_buffer);
@@ -652,10 +654,15 @@ g_omx_port_enable (GOmxPort *port)
     OMX_SendCommand (g_omx_core_get_handle (port->core),
             OMX_CommandPortEnable, port->port_index, NULL);
 
+    g_omx_port_allocate_buffers (port);
+
     g_sem_down (port->core->port_sem);
 
     port->enabled = TRUE;
 
+    if (port->core->omx_state == OMX_StateExecuting)
+        g_omx_port_start_buffers (port);
+
     DEBUG (port, "end");
 }
 
@@ -669,6 +676,8 @@ g_omx_port_disable (GOmxPort *port)
     OMX_SendCommand (g_omx_core_get_handle (port->core),
             OMX_CommandPortDisable, port->port_index, NULL);
 
+    g_omx_port_free_buffers (port);
+
     g_sem_down (port->core->port_sem);
 
     DEBUG (port, "end");
diff --git a/tests/cameratest.py b/tests/cameratest.py
new file mode 100755
index 0000000..7f220f2
--- /dev/null
+++ b/tests/cameratest.py
@@ -0,0 +1,91 @@
+#!/usr/bin/env python
+# -*- Mode: Python -*-
+# vi:si:et:sw=4:sts=4:ts=4
+# ChangeLog:
+# 2008-02-20 - Initial Version
+
+
+import os
+import gc
+import sys
+import time
+import threading
+
+import gobject
+
+import gst
+import gst.interfaces
+
+loop = gobject.MainLoop()
+
+#pipeline = "omx_camera vstab=1 mode=1 vnf=1 name=cam cam.src ! queue ! fakesink sync=false cam.vidsrc ! video/x-raw-yuv, format=(fourcc)UYVY, width=720, height=480, framerate=30/1 ! queue ! fakesink sync=false"
+pipeline = '''
+omx_camera name=cam
+  cam.src    ! queue ! fakesink sync=false async=false
+  cam.imgsrc ! image/jpeg, width=720, height=480 ! queue ! fakesink sync=false async=false
+  cam.vidsrc ! video/x-raw-yuv, format=(fourcc)UYVY, width=720, height=480, framerate=30/1 ! queue ! fakesink sync=false async=false
+'''
+
+bin = gst.parse_launch(pipeline)
+
+
+i = 0
+
+def on_timeout():
+  global i
+  if i == 0:
+    print "setting state to paused"
+    bin.set_state(gst.STATE_PAUSED)
+  elif i == 1:
+    print "switching to video mode"
+    cam.set_property('mode', 'video')
+    print "setting state to playing"
+    bin.set_state(gst.STATE_PLAYING)
+  elif i == 2:
+    print "setting state to paused"
+    bin.set_state(gst.STATE_PAUSED)
+  elif i == 3:
+    print "switching to image mode"
+    cam.set_property('mode', 'image')
+    print "setting state to playing"
+    bin.set_state(gst.STATE_PLAYING)
+  i = i + 1
+  return False
+
+
+def on_message(bus, message):
+  global bin
+  t = message.type
+  if t == gst.MESSAGE_ERROR:
+    err, debug = message.parse_error()
+    print "Error: %s" % err, debug
+  elif t == gst.MESSAGE_EOS:
+    print "eos"
+  elif t == gst.MESSAGE_STATE_CHANGED:
+    oldstate, newstate, pending = message.parse_state_changed()
+    elem = message.src
+    print "State Changed: %s: %s --> %s" % (elem, oldstate.value_name, newstate.value_name)
+    if elem == bin:
+      print "State Change complete.. triggering next step"
+      gobject.timeout_add(10000, on_timeout)
+
+
+bus = bin.get_bus()
+bus.enable_sync_message_emission()
+bus.add_signal_watch()
+bus.connect('message', on_message)
+
+
+cam = None;
+
+for elem in bin:
+  if elem.get_name().startswith("cam"):
+    cam = elem
+    break
+
+print "setting state to playing"
+bin.set_state(gst.STATE_PLAYING)
+
+
+loop.run()
+
diff --git a/tests/standalone/core.c b/tests/standalone/core.c
index 660eaef..bfc340d 100644
--- a/tests/standalone/core.c
+++ b/tests/standalone/core.c
@@ -176,13 +176,13 @@ comp_SendCommand (OMX_HANDLETYPE handle,
                 {
                     OMX_BUFFERHEADERTYPE *buffer;
 
-                    while (buffer = async_queue_pop_forced (private->ports[0].queue))
+                    while (buffer = async_queue_pop_full (private->ports[0].queue, FALSE, TRUE))
                     {
                         private->callbacks->EmptyBufferDone (comp,
                                                              private->app_data, buffer);
                     }
 
-                    while (buffer = async_queue_pop_forced (private->ports[1].queue))
+                    while (buffer = async_queue_pop_full (private->ports[1].queue, FALSE, TRUE))
                     {
                         private->callbacks->FillBufferDone (comp,
                                                             private->app_data, buffer);
diff --git a/util/async_queue.c b/util/async_queue.c
index 95833dc..71b8695 100644
--- a/util/async_queue.c
+++ b/util/async_queue.c
@@ -64,19 +64,19 @@ async_queue_push (AsyncQueue *queue,
 }
 
 gpointer
-async_queue_pop (AsyncQueue *queue)
+async_queue_pop_full (AsyncQueue *queue, gboolean wait, gboolean force)
 {
     gpointer data = NULL;
 
     g_mutex_lock (queue->mutex);
 
-    if (!queue->enabled)
+    if (!force && !queue->enabled)
     {
         /* g_warning ("not enabled!"); */
         goto leave;
     }
 
-    if (!queue->tail)
+    if (wait && !queue->tail)
     {
         g_cond_wait (queue->condition, queue->mutex);
     }
@@ -102,29 +102,9 @@ leave:
 }
 
 gpointer
-async_queue_pop_forced (AsyncQueue *queue)
+async_queue_pop (AsyncQueue *queue)
 {
-    gpointer data = NULL;
-
-    g_mutex_lock (queue->mutex);
-
-    if (queue->tail)
-    {
-        GList *node = queue->tail;
-        data = node->data;
-
-        queue->tail = node->prev;
-        if (queue->tail)
-            queue->tail->next = NULL;
-        else
-            queue->head = NULL;
-        queue->length--;
-        g_list_free_1 (node);
-    }
-
-    g_mutex_unlock (queue->mutex);
-
-    return data;
+    return async_queue_pop_full (queue, TRUE, FALSE);
 }
 
 void
diff --git a/util/async_queue.h b/util/async_queue.h
index eec497e..3fb9c09 100644
--- a/util/async_queue.h
+++ b/util/async_queue.h
@@ -39,8 +39,8 @@ struct AsyncQueue
 AsyncQueue *async_queue_new (void);
 void async_queue_free (AsyncQueue *queue);
 void async_queue_push (AsyncQueue *queue, gpointer data);
+gpointer async_queue_pop_full (AsyncQueue *queue, gboolean wait, gboolean force);
 gpointer async_queue_pop (AsyncQueue *queue);
-gpointer async_queue_pop_forced (AsyncQueue *queue);
 void async_queue_disable (AsyncQueue *queue);
 void async_queue_enable (AsyncQueue *queue);
 void async_queue_flush (AsyncQueue *queue);
-- 
1.6.3.2

