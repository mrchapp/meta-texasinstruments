From ad887352fd8fc599a5530a313333f173cda253f2 Mon Sep 17 00:00:00 2001
From: Roberto Castaneda <rsheissa@ti.com>
Date: Tue, 3 Nov 2009 17:16:54 -0600
Subject: [PATCH] aacparse: New implementation.

This new implementation does not use gstbaseparse. It is based on the gstfaad code. Therefore, it depends on FAAD and GSTFAAD to work. Accepts inputs from AAC audio only or demuxed audio files. Provides correct caps to the decoder component for HE and eAAC+ streams.
---
 gst/aacparse/Makefile.am   |   11 +-
 gst/aacparse/gstaacparse.c | 1681 ++++++++++++++++++++++++++------------------
 gst/aacparse/gstaacparse.h |  138 ++---
 3 files changed, 1060 insertions(+), 770 deletions(-)

diff --git a/gst/aacparse/Makefile.am b/gst/aacparse/Makefile.am
index 1341e8d..4824650 100644
--- a/gst/aacparse/Makefile.am
+++ b/gst/aacparse/Makefile.am
@@ -1,11 +1,10 @@
 plugin_LTLIBRARIES = libgstaacparse.la
 
-libgstaacparse_la_SOURCES = \
-	gstaacparse.c gstbaseparse.c
-
+libgstaacparse_la_SOURCES = gstaacparse.c
 libgstaacparse_la_CFLAGS = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS)
-libgstaacparse_la_LIBADD = $(GST_BASE_LIBS)
-libgstaacparse_la_LDFLAGS = $(PACKAGE_LIBS) $(GST_PLUGIN_LDFLAGS)
+libgstaacparse_la_LIBADD = $(FAAD_LIBS) $(GST_PLUGINS_BASE_LIBS) \
+	-lgstaudio-@GST_MAJORMINOR@
+libgstaacparse_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
 libgstaacparse_la_LIBTOOLFLAGS = --tag=disable-static
 
-noinst_HEADERS = gstaacparse.h gstbaseparse.h
+noinst_HEADERS = gstaacparse.h
diff --git a/gst/aacparse/gstaacparse.c b/gst/aacparse/gstaacparse.c
index 9bb5c10..f1e7a5b 100644
--- a/gst/aacparse/gstaacparse.c
+++ b/gst/aacparse/gstaacparse.c
@@ -1,7 +1,7 @@
-/* GStreamer AAC parser plugin
- * Copyright (C) 2008 Nokia Corporation. All rights reserved.
- *
- * Contact: Stefan Kost <stefan.kost@nokia.com>
+/* GStreamer AAC Parser plugin.
+ * Based on the FAAD (Free AAC Decoder) plugin
+ * Copyright (C) 2003 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ * Copyright (C) 2006 Tim-Philipp MÃ¼ller <tim centricular net>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -19,866 +19,1179 @@
  * Boston, MA 02111-1307, USA.
  */
 
-/**
- * SECTION:gstaacparse
- * @short_description: AAC parser
- * @see_also: #GstAmrParse
- *
- * <refsect2>
- * <para>
- * This is an AAC parser. It can handle both ADIF and ADTS stream formats.
- * The parser inherits from #GstBaseParse and therefore in only needs to
- * implement AAC-specific functionality.
- * </para>
- * <para>
- * As ADIF format is not framed, it is not seekable. From the same reason
- * stream duration cannot be calculated either. Instead, AAC clips that are
- * in ADTS format can be seeked, and parser also is able to calculate their
- * playback position and clip duration.
- * </para>
- * <title>Example launch line</title>
- * <para>
- * <programlisting>
- * gst-launch filesrc location=abc.aac ! aacparse ! faad ! audioresample ! audioconvert ! alsasink
- * </programlisting>
- * </para>
- * </refsect2>
- */
-
-#include <string.h>
-
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
-#include "gstaacparse.h"
-
-
-static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
-    GST_PAD_SRC,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/mpeg, "
-        "framed = (boolean) true, " "mpegversion = (int) { 2, 4 };"));
-
-static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/mpeg, "
-        "framed = (boolean) false, " "mpegversion = (int) { 2, 4 };"));
-
-GST_DEBUG_CATEGORY_STATIC (gst_aacparse_debug);
-#define GST_CAT_DEFAULT gst_aacparse_debug
-
-
-#define ADIF_MAX_SIZE 40        /* Should be enough */
-#define ADTS_MAX_SIZE 10        /* Should be enough */
-
+#include <string.h>
+#include <gst/audio/audio.h>
+#include <gst/audio/multichannel.h>
 
-#define AAC_FRAME_DURATION(parse) (GST_SECOND/parse->frames_per_sec)
+/* These are the correct types for these functions, as defined in the source,
+ * with types changed to match glib types, since those are defined for us.
+ * However, upstream AACPARSE is distributed with a broken header file that defined
+ * these wrongly (in a way which was broken on 64 bit systems).
+ *
+ * Upstream CVS still has the bug, but has also renamed all the public symbols
+ * for Better Corporate Branding (or whatever), so we need to take that
+ * (FAAD_IS_NEAAC) into account as well.
+ *
+ * We must call them using these definitions. Most distributions now have the
+ * corrected header file (they distribute a patch along with the source),
+ * but not all, hence this Truly Evil Hack.
+ *
+ * Note: The prototypes don't need to be defined conditionaly, as the cpp will
+ * do that for us.
+ */
+#if FAAD2_MINOR_VERSION < 7
+#ifdef FAAD_IS_NEAAC
+#define NeAACDecInit NeAACDecInit_no_definition
+#define NeAACDecInit2 NeAACDecInit2_no_definition
+#else
+#define faacDecInit faacDecInit_no_definition
+#define faacDecInit2 faacDecInit2_no_definition
+#endif
+#endif /* FAAD2_MINOR_VERSION < 7 */
 
-static void gst_aacparse_finalize (GObject * object);
+#include "gstaacparse.h"
 
-gboolean gst_aacparse_start (GstBaseParse * parse);
-gboolean gst_aacparse_stop (GstBaseParse * parse);
+#if FAAD2_MINOR_VERSION < 7
+#ifdef FAAD_IS_NEAAC
+#undef NeAACDecInit
+#undef NeAACDecInit2
+#else
+#undef faacDecInit
+#undef faacDecInit2
+#endif
 
-static gboolean gst_aacparse_sink_setcaps (GstBaseParse * parse,
-    GstCaps * caps);
+extern long faacDecInit (faacDecHandle, guint8 *, guint32, guint32 *, guint8 *);
+extern gint8 faacDecInit2 (faacDecHandle, guint8 *, guint32,
+    guint32 *, guint8 *);
 
-gboolean gst_aacparse_check_valid_frame (GstBaseParse * parse,
-    GstBuffer * buffer, guint * size, gint * skipsize);
+#endif /* FAAD2_MINOR_VERSION < 7 */
 
-GstFlowReturn gst_aacparse_parse_frame (GstBaseParse * parse,
-    GstBuffer * buffer);
+GST_DEBUG_CATEGORY_STATIC (aacparse_debug);
+#define GST_CAT_DEFAULT aacparse_debug
 
-gboolean gst_aacparse_convert (GstBaseParse * parse,
-    GstFormat src_format,
-    gint64 src_value, GstFormat dest_format, gint64 * dest_value);
+#define MAX_DECODE_ERRORS 5
 
-gboolean gst_aacparse_is_seekable (GstBaseParse * parse);
+static const GstElementDetails aacparse_details =
+GST_ELEMENT_DETAILS ("AAC audio decoder",
+    "Codec/Decoder/Audio",
+    "Free MPEG-2/4 AAC decoder",
+    "Ronald Bultje <rbultje@ronald.bitfreak.net>");
 
-gboolean gst_aacparse_event (GstBaseParse * parse, GstEvent * event);
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/mpeg, " "mpegversion = (int) { 2, 4 }")
+    );
+
+#define STATIC_INT_CAPS(bpp) \
+  "audio/mpeg, " \
+    "mpegversion = (int) 4, " \
+    "channels = (int) [ 1, 2 ], " \
+    "rate = (int) [ 8000, 96000 ], " \
+    "object_type = (int) [ 1, 6 ]"
+
+
+/*
+ * All except 16-bit integer are disabled until someone fixes FAAD.
+ * FAAD allocates approximately 8*1024*2 bytes bytes, which is enough
+ * for 1 frame (1024 samples) of 6 channel (5.1) 16-bit integer 16bpp
+ * audio, but not for any other. You'll get random segfaults, crashes
+ * and even valgrind goes crazy.
+ */
 
-#define _do_init(bla) \
-    GST_DEBUG_CATEGORY_INIT (gst_aacparse_debug, "aacparse", 0, \
-    "AAC audio stream parser");
+#define STATIC_CAPS \
+  STATIC_INT_CAPS (16)
 
-GST_BOILERPLATE_FULL (GstAacParse, gst_aacparse, GstBaseParse,
-    GST_TYPE_BASE_PARSE, _do_init);
 
-static inline gint
-gst_aacparse_get_sample_rate_from_index (guint sr_idx)
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (STATIC_CAPS)
+    );
+
+static void gst_aacparse_base_init (GstAacParseClass * klass);
+static void gst_aacparse_class_init (GstAacParseClass * klass);
+static void gst_aacparse_init (GstAacParse * aacparse);
+static void gst_aacparse_dispose (GObject * object);
+
+static gboolean gst_aacparse_setcaps (GstPad * pad, GstCaps * caps);
+static GstCaps *gst_aacparse_srcgetcaps (GstPad * pad);
+static gboolean gst_aacparse_src_event (GstPad * pad, GstEvent * event);
+static gboolean gst_aacparse_sink_event (GstPad * pad, GstEvent * event);
+static gboolean gst_aacparse_src_query (GstPad * pad, GstQuery * query);
+static GstFlowReturn gst_aacparse_chain (GstPad * pad, GstBuffer * buffer);
+static GstStateChangeReturn gst_aacparse_change_state (GstElement * element,
+    GstStateChange transition);
+static gboolean gst_aacparse_src_convert (GstAacParse * aacparse, GstFormat src_format,
+    gint64 src_val, GstFormat dest_format, gint64 * dest_val);
+static gboolean gst_aacparse_open_decoder (GstAacParse * aacparse);
+static void gst_aacparse_close_decoder (GstAacParse * aacparse);
+
+static GstElementClass *parent_class;   /* NULL */
+
+GType
+gst_aacparse_get_type (void)
 {
-  static const guint aac_sample_rates[] = { 96000, 88200, 64000, 48000, 44100,
-    32000, 24000, 22050, 16000, 12000, 11025, 8000
-  };
-
-  if (sr_idx < G_N_ELEMENTS (aac_sample_rates))
-    return aac_sample_rates[sr_idx];
-  GST_WARNING ("Invalid sample rate index %u", sr_idx);
-  return 0;
+  static GType gst_aacparse_type = 0;
+
+  if (!gst_aacparse_type) {
+    static const GTypeInfo gst_aacparse_info = {
+      sizeof (GstAacParseClass),
+      (GBaseInitFunc) gst_aacparse_base_init,
+      NULL,
+      (GClassInitFunc) gst_aacparse_class_init,
+      NULL,
+      NULL,
+      sizeof (GstAacParse),
+      0,
+      (GInstanceInitFunc) gst_aacparse_init,
+    };
+
+    gst_aacparse_type = g_type_register_static (GST_TYPE_ELEMENT,
+        "GstAacParse", &gst_aacparse_info, 0);
+  }
+
+  return gst_aacparse_type;
 }
 
-/**
- * gst_aacparse_base_init:
- * @klass: #GstElementClass.
- *
- */
 static void
-gst_aacparse_base_init (gpointer klass)
+gst_aacparse_base_init (GstAacParseClass * klass)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
-  GstElementDetails details = GST_ELEMENT_DETAILS ("AAC audio stream parser",
-      "Codec/Parser/Audio",
-      "Advanced Audio Coding parser",
-      "Stefan Kost <stefan.kost@nokia.com>");
 
   gst_element_class_add_pad_template (element_class,
-      gst_static_pad_template_get (&sink_template));
-  gst_element_class_add_pad_template (element_class,
       gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
 
-  gst_element_class_set_details (element_class, &details);
-}
+  gst_element_class_set_details (element_class, &aacparse_details);
 
+  GST_DEBUG_CATEGORY_INIT (aacparse_debug, "aacparse", 0, "AAC decoding");
+}
 
-/**
- * gst_aacparse_class_init:
- * @klass: #GstAacParseClass.
- *
- */
 static void
 gst_aacparse_class_init (GstAacParseClass * klass)
 {
-  GObjectClass *object_class = G_OBJECT_CLASS (klass);
-  GstBaseParseClass *parse_class = GST_BASE_PARSE_CLASS (klass);
-
-  object_class->finalize = gst_aacparse_finalize;
-
-  parse_class->start = GST_DEBUG_FUNCPTR (gst_aacparse_start);
-  parse_class->stop = GST_DEBUG_FUNCPTR (gst_aacparse_stop);
-  parse_class->event = GST_DEBUG_FUNCPTR (gst_aacparse_event);
-  parse_class->convert = GST_DEBUG_FUNCPTR (gst_aacparse_convert);
-  parse_class->set_sink_caps = GST_DEBUG_FUNCPTR (gst_aacparse_sink_setcaps);
-  parse_class->is_seekable = GST_DEBUG_FUNCPTR (gst_aacparse_is_seekable);
-  parse_class->parse_frame = GST_DEBUG_FUNCPTR (gst_aacparse_parse_frame);
-  parse_class->check_valid_frame =
-      GST_DEBUG_FUNCPTR (gst_aacparse_check_valid_frame);
-}
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
 
+  parent_class = g_type_class_peek_parent (klass);
+
+  gobject_class->dispose = GST_DEBUG_FUNCPTR (gst_aacparse_dispose);
+
+  gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_aacparse_change_state);
+}
 
-/**
- * gst_aacparse_init:
- * @aacparse: #GstAacParse.
- * @klass: #GstAacParseClass.
- *
- */
 static void
-gst_aacparse_init (GstAacParse * aacparse, GstAacParseClass * klass)
+gst_aacparse_init (GstAacParse * aacparse)
 {
-  /* init rest */
-  gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse), 1024);
-  aacparse->ts = 0;
-  GST_DEBUG ("initialized");
+  aacparse->handle = NULL;
+  aacparse->samplerate = -1;
+  aacparse->channels = -1;
+  aacparse->codec_info = NULL;
+  aacparse->need_channel_setup = TRUE;
+  aacparse->channel_positions = NULL;
+  aacparse->init = FALSE;
+  aacparse->next_ts = 0;
+  aacparse->prev_ts = GST_CLOCK_TIME_NONE;
+  aacparse->bytes_in = 0;
+  aacparse->sum_dur_out = 0;
+  aacparse->packetised = FALSE;
+  aacparse->error_count = 0;
+  aacparse->segment = gst_segment_new ();
+  aacparse->adapter = gst_adapter_new ();
+
+  aacparse->sinkpad = gst_pad_new_from_static_template (&sink_template, "sink");
+  gst_element_add_pad (GST_ELEMENT (aacparse), aacparse->sinkpad);
+  gst_pad_set_event_function (aacparse->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_sink_event));
+  gst_pad_set_setcaps_function (aacparse->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_setcaps));
+  gst_pad_set_chain_function (aacparse->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_chain));
+
+  aacparse->srcpad = gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_use_fixed_caps (aacparse->srcpad);
+  gst_pad_set_getcaps_function (aacparse->srcpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_srcgetcaps));
+  gst_pad_set_query_function (aacparse->srcpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_src_query));
+  gst_pad_set_event_function (aacparse->srcpad,
+      GST_DEBUG_FUNCPTR (gst_aacparse_src_event));
+  gst_element_add_pad (GST_ELEMENT (aacparse), aacparse->srcpad);
 }
 
-
-/**
- * gst_aacparse_finalize:
- * @object:
- *
- */
 static void
-gst_aacparse_finalize (GObject * object)
+gst_aacparse_dispose (GObject * object)
 {
-  GstAacParse *aacparse;
+  GstAacParse *aacparse = GST_AACPARSE (object);
 
-  aacparse = GST_AACPARSE (object);
-  G_OBJECT_CLASS (parent_class)->finalize (object);
-}
+  if (aacparse->segment) {
+    gst_segment_free (aacparse->segment);
+    aacparse->segment = NULL;
+  }
 
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
 
-/**
- * gst_aacparse_set_src_caps:
- * @aacparse: #GstAacParse.
- * @sink_caps: (proposed) caps of sink pad
- *
- * Set source pad caps according to current knowledge about the
- * audio stream.
- *
- * Returns: TRUE if caps were successfully set.
- */
-static gboolean
-gst_aacparse_set_src_caps (GstAacParse * aacparse, GstCaps * sink_caps)
+static void
+gst_aacparse_send_tags (GstAacParse * aacparse)
 {
-  GstStructure *s;
-  GstCaps *src_caps = NULL;
-  gboolean res = FALSE;
-
-  GST_DEBUG_OBJECT (aacparse, "sink caps: %" GST_PTR_FORMAT, sink_caps);
-  if (sink_caps)
-    src_caps = gst_caps_copy (sink_caps);
-  else
-    src_caps = gst_caps_new_simple ("audio/mpeg", NULL);
-
-  gst_caps_set_simple (src_caps, "framed", G_TYPE_BOOLEAN, TRUE,
-      "mpegversion", G_TYPE_INT, aacparse->mpegversion, NULL);
+  GstTagList *tags;
 
-  s = gst_caps_get_structure (src_caps, 0);
-  if (!gst_structure_has_field (s, "rate") && aacparse->sample_rate > 0)
-    gst_structure_set (s, "rate", G_TYPE_INT, aacparse->sample_rate, NULL);
-  if (!gst_structure_has_field (s, "channels") && aacparse->channels > 0)
-    gst_structure_set (s, "channels", G_TYPE_INT, aacparse->channels, NULL);
+  tags = gst_tag_list_new ();
 
-  GST_DEBUG_OBJECT (aacparse, "setting src caps: %" GST_PTR_FORMAT, src_caps);
+  gst_tag_list_add (tags, GST_TAG_MERGE_REPLACE,
+      GST_TAG_AUDIO_CODEC, "MPEG-4 AAC audio", NULL);
 
-  gst_pad_use_fixed_caps (GST_BASE_PARSE (aacparse)->srcpad);
-  res = gst_pad_set_caps (GST_BASE_PARSE (aacparse)->srcpad, src_caps);
-  gst_caps_unref (src_caps);
-  return res;
+  gst_element_found_tags (GST_ELEMENT (aacparse), tags);
 }
 
+static gint
+aac_rate_idx (gint rate)
+{
+  if (92017 <= rate)
+    return 0;
+  else if (75132 <= rate)
+    return 1;
+  else if (55426 <= rate)
+    return 2;
+  else if (46009 <= rate)
+    return 3;
+  else if (37566 <= rate)
+    return 4;
+  else if (27713 <= rate)
+    return 5;
+  else if (23004 <= rate)
+    return 6;
+  else if (18783 <= rate)
+    return 7;
+  else if (13856 <= rate)
+    return 8;
+  else if (11502 <= rate)
+    return 9;
+  else if (9391 <= rate)
+    return 10;
+  else
+    return 11;
+}
 
-/**
- * gst_aacparse_sink_setcaps:
- * @sinkpad: GstPad
- * @caps: GstCaps
- *
- * Implementation of "set_sink_caps" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE on success.
- */
 static gboolean
-gst_aacparse_sink_setcaps (GstBaseParse * parse, GstCaps * caps)
+gst_aacparse_setcaps (GstPad * pad, GstCaps * caps)
 {
-  GstAacParse *aacparse;
-  GstStructure *structure;
-  gchar *caps_str;
+  GstAacParse *aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
+  GstStructure *str = gst_caps_get_structure (caps, 0);
+  GstBuffer *buf;
+  const GValue *value;
+
+  /* Assume raw stream */
+  aacparse->packetised = FALSE;
+
+  if ((value = gst_structure_get_value (str, "codec_data"))) {
+#if FAAD2_MINOR_VERSION >= 7
+    unsigned long samplerate;
+#else
+    guint32 samplerate;
+#endif
+    guint8 channels;
+    guint8 *cdata;
+    guint csize;
+
+    /* We have codec data, means packetised stream */
+    aacparse->packetised = TRUE;
+    buf = gst_value_get_buffer (value);
+    aacparse->codec_info = gst_buffer_copy (buf);
+
+    cdata = GST_BUFFER_DATA (buf);
+    csize = GST_BUFFER_SIZE (buf);
+
+    if (csize < 2)
+      goto wrong_length;
+
+    GST_DEBUG ("codec_data: object_type=%d, sample_rate=%d, channels=%d",
+        ((cdata[0] & 0xf8) >> 3),
+        (((cdata[0] & 0x07) << 1) | ((cdata[1] & 0x80) >> 7)),
+        ((cdata[1] & 0x78) >> 3));
+
+    /* someone forgot that char can be unsigned when writing the API */
+    if ((gint8) faacDecInit2 (aacparse->handle, cdata, csize, &samplerate,
+            &channels) < 0)
+      goto init_failed;
+
+    if (channels != ((cdata[1] & 0x78) >> 3)) {
+      /* https://bugs.launchpad.net/ubuntu/+source/faad2/+bug/290259 */
+      GST_WARNING_OBJECT (aacparse,
+          "buggy aacparse version, wrong number of channels %d instead of %d", channels,
+          ((cdata[1] & 0x78) >> 3));
+    }
 
-  aacparse = GST_AACPARSE (parse);
-  structure = gst_caps_get_structure (caps, 0);
-  caps_str = gst_caps_to_string (caps);
+    GST_DEBUG_OBJECT (aacparse, "codec_data init: channels=%u, rate=%u", channels,
+        samplerate);
 
-  GST_DEBUG_OBJECT (aacparse, "setcaps: %s", caps_str);
-  g_free (caps_str);
+    /* not updating these here, so they are updated in the
+     * chain function, and new caps are created etc. */
+    aacparse->samplerate = 0;
+    aacparse->channels = 0;
 
-  // This is needed at least in case of RTP
-  // Parses the codec_data information to get ObjectType,
-  // number of channels and samplerate
-  if (gst_structure_has_field (structure, "codec_data")) {
+    aacparse->init = TRUE;
+  } else if ((value = gst_structure_get_value (str, "framed")) &&
+      g_value_get_boolean (value) == TRUE) {
+    aacparse->packetised = TRUE;
+    GST_DEBUG_OBJECT (aacparse, "we have packetized audio");
+  } else {
+    aacparse->init = FALSE;
+  }
 
-    const GValue *value = gst_structure_get_value (structure, "codec_data");
+  aacparse->fake_codec_data[0] = 0;
+  aacparse->fake_codec_data[1] = 0;
 
-    if (value) {
-      GstBuffer *buf = gst_value_get_buffer (value);
-      const guint8 *buffer = GST_BUFFER_DATA (buf);
-      guint sr_idx;
+  if (aacparse->packetised) {
+    gint rate, channels;
 
-      sr_idx = ((buffer[0] & 0x07) << 1) | ((buffer[1] & 0x80) >> 7);
-      aacparse->object_type = (buffer[0] & 0xf8) >> 3;
-      aacparse->sample_rate = gst_aacparse_get_sample_rate_from_index (sr_idx);
-      aacparse->channels = (buffer[1] & 0x78) >> 3;
-      aacparse->header_type = DSPAAC_HEADER_NONE;
-      aacparse->mpegversion = 4;
+    if (gst_structure_get_int (str, "rate", &rate) &&
+        gst_structure_get_int (str, "channels", &channels)) {
+      gint rate_idx, profile;
 
-      GST_DEBUG ("codec_data: object_type=%d, sample_rate=%d, channels=%d",
-          aacparse->object_type, aacparse->sample_rate, aacparse->channels);
+      profile = 3;              /* 0=MAIN, 1=LC, 2=SSR, 3=LTP */
+      rate_idx = aac_rate_idx (rate);
 
-      /* arrange for metadata and get out of the way */
-      gst_aacparse_set_src_caps (aacparse, caps);
-      gst_base_parse_set_passthrough (parse, TRUE);
-    } else
-      return FALSE;
+      aacparse->fake_codec_data[0] = ((profile + 1) << 3) | ((rate_idx & 0xE) >> 1);
+      aacparse->fake_codec_data[1] = ((rate_idx & 0x1) << 7) | (channels << 3);
+      GST_LOG_OBJECT (aacparse, "created fake codec data (%u,%u): 0x%x 0x%x", rate,
+          channels, (int) aacparse->fake_codec_data[0],
+          (int) aacparse->fake_codec_data[1]);
+    }
   }
 
+  aacparse->need_channel_setup = TRUE;
+
+  if (!aacparse->packetised)
+    gst_aacparse_send_tags (aacparse);
+
   return TRUE;
+
+  /* ERRORS */
+wrong_length:
+  {
+    GST_DEBUG_OBJECT (aacparse, "codec_data less than 2 bytes long");
+    return FALSE;
+  }
+init_failed:
+  {
+    GST_DEBUG_OBJECT (aacparse, "faacDecInit2() failed");
+    return FALSE;
+  }
 }
 
 
-/**
- * gst_aacparse_update_duration:
- * @aacparse: #GstAacParse.
- *
- */
-static void
-gst_aacparse_update_duration (GstAacParse * aacparse)
+static GstAudioChannelPosition *
+gst_aacparse_chanpos_to_gst (GstAacParse * aacparse, guchar * fpos, guint num,
+    gboolean * channel_map_failed)
 {
-  GstPad *peer;
-  GstBaseParse *parse;
+  GstAudioChannelPosition *pos;
+  guint n;
+  gboolean unknown_channel = FALSE;
+
+  *channel_map_failed = FALSE;
+
+  /* special handling for the common cases for mono and stereo */
+  if (num == 1 && fpos[0] == FRONT_CHANNEL_CENTER) {
+    GST_DEBUG_OBJECT (aacparse, "mono common case; won't set channel positions");
+    return NULL;
+  } else if (num == 2 && fpos[0] == FRONT_CHANNEL_LEFT
+      && fpos[1] == FRONT_CHANNEL_RIGHT) {
+    GST_DEBUG_OBJECT (aacparse, "stereo common case; won't set channel positions");
+    return NULL;
+  }
 
-  parse = GST_BASE_PARSE (aacparse);
+  pos = g_new (GstAudioChannelPosition, num);
+  for (n = 0; n < num; n++) {
+    GST_DEBUG_OBJECT (aacparse, "aacparse channel %d as %d", n, fpos[n]);
+    switch (fpos[n]) {
+      case FRONT_CHANNEL_LEFT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT;
+        break;
+      case FRONT_CHANNEL_RIGHT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT;
+        break;
+      case FRONT_CHANNEL_CENTER:
+        /* argh, mono = center */
+        if (num == 1)
+          pos[n] = GST_AUDIO_CHANNEL_POSITION_FRONT_MONO;
+        else
+          pos[n] = GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER;
+        break;
+      case SIDE_CHANNEL_LEFT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT;
+        break;
+      case SIDE_CHANNEL_RIGHT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT;
+        break;
+      case BACK_CHANNEL_LEFT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_REAR_LEFT;
+        break;
+      case BACK_CHANNEL_RIGHT:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT;
+        break;
+      case BACK_CHANNEL_CENTER:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_REAR_CENTER;
+        break;
+      case LFE_CHANNEL:
+        pos[n] = GST_AUDIO_CHANNEL_POSITION_LFE;
+        break;
+      default:
+        GST_DEBUG_OBJECT (aacparse, "unknown channel %d at %d", fpos[n], n);
+        unknown_channel = TRUE;
+        break;
+    }
+  }
+  if (unknown_channel) {
+    g_free (pos);
+    pos = NULL;
+    switch (num) {
+      case 1:{
+        GST_DEBUG_OBJECT (aacparse,
+            "FAAD reports unknown 1 channel mapping. Forcing to mono");
+        break;
+      }
+      case 2:{
+        GST_DEBUG_OBJECT (aacparse,
+            "FAAD reports unknown 2 channel mapping. Forcing to stereo");
+        break;
+      }
+      default:{
+        GST_WARNING ("Unsupported FAAD channel position 0x%x encountered",
+            fpos[n]);
+        *channel_map_failed = TRUE;
+        break;
+      }
+    }
+  }
 
-  /* Cannot estimate duration. No data has been passed to us yet */
-  if (!aacparse->framecount || !aacparse->frames_per_sec) {
-    return;
+  return pos;
+}
+
+static GstCaps *
+gst_aacparse_srcgetcaps (GstPad * pad)
+{
+  GstAacParse *aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
+  static GstAudioChannelPosition *supported_positions = NULL;
+  static gint num_supported_positions = LFE_CHANNEL - FRONT_CHANNEL_CENTER + 1;
+  GstCaps *templ;
+
+  if (!supported_positions) {
+    guchar *supported_fpos = g_new0 (guchar, num_supported_positions);
+    gint n;
+    gboolean map_failed;
+
+    for (n = 0; n < num_supported_positions; n++) {
+      supported_fpos[n] = n + FRONT_CHANNEL_CENTER;
+    }
+    supported_positions = gst_aacparse_chanpos_to_gst (aacparse, supported_fpos,
+        num_supported_positions, &map_failed);
+    g_free (supported_fpos);
   }
-  // info->length = (int)((filelength_filestream(file)/(((info->bitrate*8)/1024)*16))*1000);
 
-  peer = gst_pad_get_peer (parse->sinkpad);
-  if (peer) {
-    GstFormat pformat = GST_FORMAT_BYTES;
-    guint64 bpf = aacparse->bytecount / aacparse->framecount;
-    gboolean qres = FALSE;
-    gint64 ptot;
+  if (aacparse->handle != NULL && aacparse->channels != -1 && aacparse->samplerate != -1) {
+    GstCaps *caps = gst_caps_new_empty ();
+    GstStructure *str;
+    gint fmt[] = {
+      FAAD_FMT_16BIT,
+      -1
+    }
+    , n;
+
+    for (n = 0; fmt[n] != -1; n++) {
+      switch (fmt[n]) {
+        case FAAD_FMT_16BIT:
+          str = gst_structure_new ("audio/mpeg",
+              "mpegversion", G_TYPE_INT, 4, NULL);
+          break;
+        default:
+          str = NULL;
+          break;
+      }
+      if (!str)
+        continue;
+
+      if (aacparse->samplerate > 0) {
+        gst_structure_set (str, "rate", G_TYPE_INT, aacparse->samplerate, NULL);
+      } else {
+        gst_structure_set (str, "rate", GST_TYPE_INT_RANGE, 8000, 96000, NULL);
+      }
+
+      if (aacparse->object_type > 0) {
+          gst_structure_set (str, "object_type", G_TYPE_INT, aacparse->object_type, NULL);
+      } else {
+          gst_structure_set (str, "object_type", GST_TYPE_INT_RANGE, 1, 6, NULL);
+      }
+
+      if (aacparse->channels > 0) {
+        gst_structure_set (str, "channels", G_TYPE_INT, aacparse->channels, NULL);
+
+        /* put channel information here */
+        if (aacparse->channel_positions) {
+          GstAudioChannelPosition *pos;
+          gboolean map_failed;
+
+          pos = gst_aacparse_chanpos_to_gst (aacparse, aacparse->channel_positions,
+              aacparse->channels, &map_failed);
+          if (map_failed) {
+            gst_structure_free (str);
+            continue;
+          }
+          if (pos) {
+            gst_audio_set_channel_positions (str, pos);
+            g_free (pos);
+          }
+        } else {
+          gst_audio_set_structure_channel_positions_list (str,
+              supported_positions, num_supported_positions);
+        }
+      } else {
+        gst_structure_set (str, "channels", GST_TYPE_INT_RANGE, 1, 8, NULL);
+        /* we set channel positions later */
+      }
+
+      gst_caps_append_structure (caps, str);
+    }
 
-    qres = gst_pad_query_duration (peer, &pformat, &ptot);
-    gst_object_unref (GST_OBJECT (peer));
-    if (qres && bpf) {
-      gst_base_parse_set_duration (parse, GST_FORMAT_TIME,
-          AAC_FRAME_DURATION (aacparse) * ptot / bpf);
+    if (aacparse->channels == -1) {
+      gst_audio_set_caps_channel_positions_list (caps,
+          supported_positions, num_supported_positions);
     }
+    gst_object_unref (aacparse);
+    return caps;
   }
+
+  /* template with channel positions */
+  templ = gst_caps_copy (GST_PAD_TEMPLATE_CAPS (GST_PAD_PAD_TEMPLATE (pad)));
+  gst_audio_set_caps_channel_positions_list (templ,
+      supported_positions, num_supported_positions);
+
+  gst_object_unref (aacparse);
+  return templ;
 }
 
 
-/**
- * gst_aacparse_adts_get_frame_len:
- * @data: block of data containing an ADTS header.
- *
- * This function calculates ADTS frame length from the given header.
- *
- * Returns: size of the ADTS frame.
- */
-static inline guint
-gst_aacparse_adts_get_frame_len (const guint8 * data)
+static void
+clear_queued (GstAacParse * aacparse)
 {
-  return ((data[3] & 0x03) << 11) | (data[4] << 3) | ((data[5] & 0xe0) >> 5);
+  g_list_foreach (aacparse->queued, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (aacparse->queued);
+  aacparse->queued = NULL;
 }
 
-
-/**
- * gst_aacparse_check_adts_frame:
- * @aacparse: #GstAacParse.
- * @data: Data to be checked.
- * @avail: Amount of data passed.
- * @framesize: If valid ADTS frame was found, this will be set to tell the
- *             found frame size in bytes.
- * @needed_data: If frame was not found, this may be set to tell how much
- *               more data is needed in the next round to detect the frame
- *               reliably. This may happen when a frame header candidate
- *               is found but it cannot be guaranteed to be the header without
- *               peeking the following data.
- *
- * Check if the given data contains contains ADTS frame. The algorithm
- * will examine ADTS frame header and calculate the frame size. Also, another
- * consecutive ADTS frame header need to be present after the found frame.
- * Otherwise the data is not considered as a valid ADTS frame. However, this
- * "extra check" is omitted when EOS has been received. In this case it is
- * enough when data[0] contains a valid ADTS header.
- *
- * This function may set the #needed_data to indicate that a possible frame
- * candidate has been found, but more data (#needed_data bytes) is needed to
- * be absolutely sure. When this situation occurs, FALSE will be returned.
- *
- * When a valid frame is detected, this function will use
- * gst_base_parse_set_min_frame_size() function from #GstBaseParse class
- * to set the needed bytes for next frame.This way next data chunk is already
- * of correct size.
- *
- * Returns: TRUE if the given data contains a valid ADTS header.
- */
-static gboolean
-gst_aacparse_check_adts_frame (GstAacParse * aacparse,
-    const guint8 * data,
-    const guint avail, guint * framesize, guint * needed_data)
+static GstFlowReturn
+flush_queued (GstAacParse * aacparse)
 {
-  if ((data[0] == 0xff) && ((data[1] & 0xf6) == 0xf0)) {
-    *framesize = gst_aacparse_adts_get_frame_len (data);
+  GstFlowReturn ret = GST_FLOW_OK;
 
-    /* In EOS mode this is enough. No need to examine the data further */
-    if (aacparse->eos) {
-      return TRUE;
-    }
+  while (aacparse->queued) {
+    GstBuffer *buf = GST_BUFFER_CAST (aacparse->queued->data);
 
-    if (*framesize + ADTS_MAX_SIZE > avail) {
-      /* We have found a possible frame header candidate, but can't be
-         sure since we don't have enough data to check the next frame */
-      GST_DEBUG ("NEED MORE DATA: we need %d, available %d",
-          *framesize + ADTS_MAX_SIZE, avail);
-      *needed_data = *framesize + ADTS_MAX_SIZE;
-      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
-          *framesize + ADTS_MAX_SIZE);
-      return FALSE;
-    }
+    GST_LOG_OBJECT (aacparse, "pushing buffer %p, timestamp %"
+        GST_TIME_FORMAT ", duration %" GST_TIME_FORMAT, buf,
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+        GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
-    if ((data[*framesize] == 0xff) && ((data[*framesize + 1] & 0xf6) == 0xf0)) {
-      guint nextlen = gst_aacparse_adts_get_frame_len (data + (*framesize));
+    /* iterate ouput queue an push downstream */
+    ret = gst_pad_push (aacparse->srcpad, buf);
 
-      GST_LOG ("ADTS frame found, len: %d bytes", *framesize);
-      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
-          nextlen + ADTS_MAX_SIZE);
-      return TRUE;
-    }
+    aacparse->queued = g_list_delete_link (aacparse->queued, aacparse->queued);
   }
-  aacparse->sync = FALSE;
-  return FALSE;
+  return ret;
 }
 
+static GstFlowReturn
+gst_aacparse_drain (GstAacParse * aacparse)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  if (aacparse->segment->rate < 0.0) {
+    /* if we have some queued frames for reverse playback, flush
+     * them now */
+    ret = flush_queued (aacparse);
+  }
+  return ret;
+}
 
-/**
- * gst_aacparse_detect_stream:
- * @aacparse: #GstAacParse.
- * @data: A block of data that needs to be examined for stream characteristics.
- * @avail: Size of the given datablock.
- * @framesize: If valid stream was found, this will be set to tell the
- *             first frame size in bytes.
- * @skipsize: If valid stream was found, this will be set to tell the first
- *            audio frame position within the given data.
- *
- * Examines the given piece of data and try to detect the format of it. It
- * checks for "ADIF" header (in the beginning of the clip) and ADTS frame
- * header. If the stream is detected, TRUE will be returned and #framesize
- * is set to indicate the found frame size. Additionally, #skipsize might
- * be set to indicate the number of bytes that need to be skipped, a.k.a. the
- * position of the frame inside given data chunk.
- *
- * Returns: TRUE on success.
- */
 static gboolean
-gst_aacparse_detect_stream (GstAacParse * aacparse,
-    const guint8 * data, const guint avail, guint * framesize, gint * skipsize)
+gst_aacparse_do_raw_seek (GstAacParse * aacparse, GstEvent * event)
 {
-  gboolean found = FALSE;
-  guint need_data = 0;
-  guint i = 0;
+  GstSeekFlags flags;
+  GstSeekType start_type, end_type;
+  GstFormat format;
+  gdouble rate;
+  gint64 start, start_time;
+
+  gst_event_parse_seek (event, &rate, &format, &flags, &start_type,
+      &start_time, &end_type, NULL);
+
+  if (rate != 1.0 ||
+      format != GST_FORMAT_TIME ||
+      start_type != GST_SEEK_TYPE_SET || end_type != GST_SEEK_TYPE_NONE) {
+    return FALSE;
+  }
 
-  GST_DEBUG_OBJECT (aacparse, "Parsing header data");
+  if (!gst_aacparse_src_convert (aacparse, GST_FORMAT_TIME, start_time,
+          GST_FORMAT_BYTES, &start)) {
+    return FALSE;
+  }
 
-  /* FIXME: No need to check for ADIF if we are not in the beginning of the
-     stream */
+  event = gst_event_new_seek (1.0, GST_FORMAT_BYTES, flags,
+      GST_SEEK_TYPE_SET, start, GST_SEEK_TYPE_NONE, -1);
 
-  /* Can we even parse the header? */
-  if (avail < ADTS_MAX_SIZE)
-    return FALSE;
+  GST_DEBUG_OBJECT (aacparse, "seeking to %" GST_TIME_FORMAT " at byte offset %"
+      G_GINT64_FORMAT, GST_TIME_ARGS (start_time), start);
+
+  return gst_pad_push_event (aacparse->sinkpad, event);
+}
+
+static gboolean
+gst_aacparse_src_event (GstPad * pad, GstEvent * event)
+{
+  GstAacParse *aacparse;
+  gboolean res;
+
+  aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
 
-  for (i = 0; i < avail - 4; i++) {
-    if (((data[i] == 0xff) && ((data[i + 1] & 0xf6) == 0xf0)) ||
-        strncmp ((char *) data + i, "ADIF", 4) == 0) {
-      found = TRUE;
-
-      if (i) {
-        /* Trick: tell the parent class that we didn't find the frame yet,
-           but make it skip 'i' amount of bytes. Next time we arrive
-           here we have full frame in the beginning of the data. */
-        *skipsize = i;
-        return FALSE;
+  GST_LOG_OBJECT (aacparse, "Handling %s event", GST_EVENT_TYPE_NAME (event));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:{
+      /* try upstream first, there might be a demuxer */
+      gst_event_ref (event);
+      if (!(res = gst_pad_push_event (aacparse->sinkpad, event))) {
+        res = gst_aacparse_do_raw_seek (aacparse, event);
       }
+      gst_event_unref (event);
       break;
     }
+    default:
+      res = gst_pad_push_event (aacparse->sinkpad, event);
+      break;
   }
-  if (!found) {
-    if (i)
-      *skipsize = i;
-    return FALSE;
-  }
-
-  if (gst_aacparse_check_adts_frame (aacparse, data, avail,
-          framesize, &need_data)) {
-    gint sr_idx;
-    GST_INFO ("ADTS ID: %d, framesize: %d", (data[1] & 0x08) >> 3, *framesize);
-
-    aacparse->header_type = DSPAAC_HEADER_ADTS;
-    sr_idx = (data[2] & 0x3c) >> 2;
 
-    aacparse->sample_rate = gst_aacparse_get_sample_rate_from_index (sr_idx);
-    aacparse->mpegversion = (data[1] & 0x08) ? 2 : 4;
-    aacparse->object_type = (data[2] & 0xc0) >> 6;
-    aacparse->channels = ((data[2] & 0x01) << 2) | ((data[3] & 0xc0) >> 6);
-    aacparse->bitrate = ((data[5] & 0x1f) << 6) | ((data[6] & 0xfc) >> 2);
+  gst_object_unref (aacparse);
+  return res;
+}
 
-    aacparse->frames_per_sec = aacparse->sample_rate / 1024.f;
+static gboolean
+gst_aacparse_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstAacParse *aacparse;
+  gboolean res = TRUE;
 
-    GST_DEBUG ("ADTS: samplerate %d, channels %d, bitrate %d, objtype %d, "
-        "fps %f", aacparse->sample_rate, aacparse->channels,
-        aacparse->bitrate, aacparse->object_type, aacparse->frames_per_sec);
+  aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
 
-    aacparse->sync = TRUE;
-    return TRUE;
-  } else if (need_data) {
-    /* This tells the parent class not to skip any data */
-    *skipsize = 0;
-    return FALSE;
-  }
+  GST_LOG_OBJECT (aacparse, "Handling %s event", GST_EVENT_TYPE_NAME (event));
 
-  if (avail < ADIF_MAX_SIZE)
-    return FALSE;
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_STOP:
+      clear_queued (aacparse);
+      res = gst_pad_push_event (aacparse->srcpad, event);
+      break;
+    case GST_EVENT_EOS:
+      gst_aacparse_drain (aacparse);
+      res = gst_pad_push_event (aacparse->srcpad, event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      GstFormat fmt;
+      gboolean is_update;
+      gint64 start, end, base;
+      gdouble rate;
+
+      gst_event_parse_new_segment (event, &is_update, &rate, &fmt, &start,
+          &end, &base);
+
+      /* drain queued buffers before we activate the new segment */
+      gst_aacparse_drain (aacparse);
+
+      if (fmt == GST_FORMAT_TIME) {
+        GST_DEBUG ("Got NEWSEGMENT event in GST_FORMAT_TIME, passing on (%"
+            GST_TIME_FORMAT " - %" GST_TIME_FORMAT ")", GST_TIME_ARGS (start),
+            GST_TIME_ARGS (end));
+        gst_segment_set_newsegment (aacparse->segment, is_update, rate, fmt, start,
+            end, base);
+      } else if (fmt == GST_FORMAT_BYTES) {
+        gint64 new_start = 0;
+        gint64 new_end = -1;
+
+        GST_DEBUG ("Got NEWSEGMENT event in GST_FORMAT_BYTES (%"
+            G_GUINT64_FORMAT " - %" G_GUINT64_FORMAT ")", start, end);
+
+        if (gst_aacparse_src_convert (aacparse, GST_FORMAT_BYTES, start,
+                GST_FORMAT_TIME, &new_start)) {
+          if (end != -1) {
+            gst_aacparse_src_convert (aacparse, GST_FORMAT_BYTES, end,
+                GST_FORMAT_TIME, &new_end);
+          }
+        } else {
+          GST_DEBUG
+              ("no average bitrate yet, sending newsegment with start at 0");
+        }
+        gst_event_unref (event);
+
+        event = gst_event_new_new_segment (is_update, rate,
+            GST_FORMAT_TIME, new_start, new_end, new_start);
+
+        gst_segment_set_newsegment (aacparse->segment, is_update, rate,
+            GST_FORMAT_TIME, new_start, new_end, new_start);
+
+        GST_DEBUG ("Sending new NEWSEGMENT event, time %" GST_TIME_FORMAT
+            " - %" GST_TIME_FORMAT, GST_TIME_ARGS (new_start),
+            GST_TIME_ARGS (new_end));
+
+        aacparse->next_ts = new_start;
+        aacparse->prev_ts = GST_CLOCK_TIME_NONE;
+      }
 
-  if (memcmp (data + i, "ADIF", 4) == 0) {
-    const guint8 *adif;
-    int skip_size = 0;
-    int bitstream_type;
-    int sr_idx;
-
-    aacparse->header_type = DSPAAC_HEADER_ADIF;
-    aacparse->mpegversion = 4;
-
-    // Skip the "ADIF" bytes
-    adif = data + i + 4;
-
-    /* copyright string */
-    if (adif[0] & 0x80)
-      skip_size += 9;           /* skip 9 bytes */
-
-    bitstream_type = adif[0 + skip_size] & 0x10;
-    aacparse->bitrate =
-        ((unsigned int) (adif[0 + skip_size] & 0x0f) << 19) |
-        ((unsigned int) adif[1 + skip_size] << 11) |
-        ((unsigned int) adif[2 + skip_size] << 3) |
-        ((unsigned int) adif[3 + skip_size] & 0xe0);
-
-    /* CBR */
-    if (bitstream_type == 0) {
-#if 0
-      /* Buffer fullness parsing. Currently not needed... */
-      guint num_elems = 0;
-      guint fullness = 0;
-
-      num_elems = (adif[3 + skip_size] & 0x1e);
-      GST_INFO ("ADIF num_config_elems: %d", num_elems);
-
-      fullness = ((unsigned int) (adif[3 + skip_size] & 0x01) << 19) |
-          ((unsigned int) adif[4 + skip_size] << 11) |
-          ((unsigned int) adif[5 + skip_size] << 3) |
-          ((unsigned int) (adif[6 + skip_size] & 0xe0) >> 5);
-
-      GST_INFO ("ADIF buffer fullness: %d", fullness);
-#endif
-      aacparse->object_type = ((adif[6 + skip_size] & 0x01) << 1) |
-          ((adif[7 + skip_size] & 0x80) >> 7);
-      sr_idx = (adif[7 + skip_size] & 0x78) >> 3;
-    }
-    /* VBR */
-    else {
-      aacparse->object_type = (adif[4 + skip_size] & 0x18) >> 3;
-      sr_idx = ((adif[4 + skip_size] & 0x07) << 1) |
-          ((adif[5 + skip_size] & 0x80) >> 7);
+      res = gst_pad_push_event (aacparse->srcpad, event);
+      break;
     }
+    default:
+      res = gst_pad_event_default (pad, event);
+      break;
+  }
 
-    /* FIXME: This gives totally wrong results. Duration calculation cannot
-       be based on this */
-    aacparse->sample_rate = gst_aacparse_get_sample_rate_from_index (sr_idx);
+  gst_object_unref (aacparse);
+  return res;
+}
 
-    aacparse->frames_per_sec = aacparse->sample_rate / 1024.f;
-    GST_INFO ("ADIF fps: %f", aacparse->frames_per_sec);
+static gboolean
+gst_aacparse_src_convert (GstAacParse * aacparse, GstFormat src_format, gint64 src_val,
+    GstFormat dest_format, gint64 * dest_val)
+{
+  guint64 bytes_in, time_out, val;
 
-    // FIXME: Can we assume this?
-    aacparse->channels = 2;
+  if (src_format == dest_format) {
+    if (dest_val)
+      *dest_val = src_val;
+    return TRUE;
+  }
 
-    GST_INFO ("ADIF: br=%d, samplerate=%d, objtype=%d",
-        aacparse->bitrate, aacparse->sample_rate, aacparse->object_type);
+  GST_OBJECT_LOCK (aacparse);
+  bytes_in = aacparse->bytes_in;
+  time_out = aacparse->sum_dur_out;
+  GST_OBJECT_UNLOCK (aacparse);
 
-    gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse), 512);
+  if (bytes_in == 0 || time_out == 0)
+    return FALSE;
 
-    *framesize = avail;
-    aacparse->sync = TRUE;
-    return TRUE;
+  /* convert based on the average bitrate so far */
+  if (src_format == GST_FORMAT_BYTES && dest_format == GST_FORMAT_TIME) {
+    val = gst_util_uint64_scale (src_val, time_out, bytes_in);
+  } else if (src_format == GST_FORMAT_TIME && dest_format == GST_FORMAT_BYTES) {
+    val = gst_util_uint64_scale (src_val, bytes_in, time_out);
+  } else {
+    return FALSE;
   }
 
-  /* This should never happen */
-  return FALSE;
-}
+  if (dest_val)
+    *dest_val = (gint64) val;
 
+  return TRUE;
+}
 
-/**
- * gst_aacparse_check_valid_frame:
- * @parse: #GstBaseParse.
- * @buffer: #GstBuffer.
- * @framesize: If the buffer contains a valid frame, its size will be put here
- * @skipsize: How much data parent class should skip in order to find the
- *            frame header.
- *
- * Implementation of "check_valid_frame" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE if buffer contains a valid frame.
- */
-gboolean
-gst_aacparse_check_valid_frame (GstBaseParse * parse,
-    GstBuffer * buffer, guint * framesize, gint * skipsize)
+static gboolean
+gst_aacparse_src_query (GstPad * pad, GstQuery * query)
 {
-  const guint8 *data;
+  gboolean res = FALSE;
   GstAacParse *aacparse;
-  gboolean ret = FALSE;
+  GstPad *peer = NULL;
 
-  aacparse = GST_AACPARSE (parse);
-  data = GST_BUFFER_DATA (buffer);
+  aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
 
-  if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
-    /* Discontinuous stream -> drop the sync */
-    aacparse->sync = FALSE;
-  }
+  GST_LOG_OBJECT (aacparse, "processing %s query", GST_QUERY_TYPE_NAME (query));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_DURATION:{
+      GstFormat format;
+      gint64 len_bytes, duration;
 
-  if (aacparse->header_type == DSPAAC_HEADER_ADIF ||
-      aacparse->header_type == DSPAAC_HEADER_NONE) {
-    /* There is nothing to parse */
-    *framesize = GST_BUFFER_SIZE (buffer);
-    ret = TRUE;
+      /* try upstream first, in case there's a demuxer */
+      if ((res = gst_pad_query_default (pad, query)))
+        break;
+
+      gst_query_parse_duration (query, &format, NULL);
+      if (format != GST_FORMAT_TIME) {
+        GST_DEBUG_OBJECT (aacparse, "query failed: can't handle format %s",
+            gst_format_get_name (format));
+        break;
+      }
 
-  } else if (aacparse->header_type == DSPAAC_HEADER_NOT_PARSED ||
-      aacparse->sync == FALSE) {
+      peer = gst_pad_get_peer (aacparse->sinkpad);
+      if (peer == NULL)
+        break;
 
-    ret = gst_aacparse_detect_stream (aacparse, data, GST_BUFFER_SIZE (buffer),
-        framesize, skipsize);
+      format = GST_FORMAT_BYTES;
+      if (!gst_pad_query_duration (peer, &format, &len_bytes)) {
+        GST_DEBUG_OBJECT (aacparse, "query failed: failed to get upstream length");
+        break;
+      }
 
-  } else if (aacparse->header_type == DSPAAC_HEADER_ADTS) {
-    guint needed_data = 1024;
+      res = gst_aacparse_src_convert (aacparse, GST_FORMAT_BYTES, len_bytes,
+          GST_FORMAT_TIME, &duration);
 
-    ret = gst_aacparse_check_adts_frame (aacparse, data,
-        GST_BUFFER_SIZE (buffer), framesize, &needed_data);
+      if (res) {
+        gst_query_set_duration (query, GST_FORMAT_TIME, duration);
 
-    if (!ret) {
-      GST_DEBUG ("buffer didn't contain valid frame");
-      gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse),
-          needed_data);
+        GST_LOG_OBJECT (aacparse, "duration estimate: %" GST_TIME_FORMAT,
+            GST_TIME_ARGS (duration));
+      }
+      break;
     }
+    case GST_QUERY_POSITION:{
+      GstFormat format;
+      gint64 pos_bytes, pos;
+
+      /* try upstream first, in case there's a demuxer */
+      if ((res = gst_pad_query_default (pad, query)))
+        break;
+
+      gst_query_parse_position (query, &format, NULL);
+      if (format != GST_FORMAT_TIME) {
+        GST_DEBUG_OBJECT (aacparse, "query failed: can't handle format %s",
+            gst_format_get_name (format));
+        break;
+      }
 
-  } else {
-    GST_DEBUG ("buffer didn't contain valid frame");
-    gst_base_parse_set_min_frame_size (GST_BASE_PARSE (aacparse), 1024);
+      peer = gst_pad_get_peer (aacparse->sinkpad);
+      if (peer == NULL)
+        break;
+
+      format = GST_FORMAT_BYTES;
+      if (!gst_pad_query_position (peer, &format, &pos_bytes)) {
+        GST_OBJECT_LOCK (aacparse);
+        pos = aacparse->next_ts;
+        GST_OBJECT_UNLOCK (aacparse);
+        res = TRUE;
+      } else {
+        res = gst_aacparse_src_convert (aacparse, GST_FORMAT_BYTES, pos_bytes,
+            GST_FORMAT_TIME, &pos);
+      }
+
+      if (res) {
+        gst_query_set_position (query, GST_FORMAT_TIME, pos);
+      }
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
   }
 
-  return ret;
+  if (peer)
+    gst_object_unref (peer);
+
+  gst_object_unref (aacparse);
+  return res;
 }
 
 
-/**
- * gst_aacparse_parse_frame:
- * @parse: #GstBaseParse.
- * @buffer: #GstBuffer.
- *
- * Implementation of "parse_frame" vmethod in #GstBaseParse class.
- *
- * Returns: GST_FLOW_OK if frame was successfully parsed and can be pushed
- *          forward. Otherwise appropriate error is returned.
- */
-GstFlowReturn
-gst_aacparse_parse_frame (GstBaseParse * parse, GstBuffer * buffer)
+static gboolean
+gst_aacparse_update_caps (GstAacParse * aacparse, faacDecFrameInfo * info)
 {
-  GstAacParse *aacparse;
-  GstFlowReturn ret = GST_FLOW_OK;
-
-  aacparse = GST_AACPARSE (parse);
-
-  if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
-    gint64 btime;
-    gboolean r = gst_aacparse_convert (parse, GST_FORMAT_BYTES,
-        GST_BUFFER_OFFSET (buffer),
-        GST_FORMAT_TIME, &btime);
-    if (r) {
-      /* FIXME: What to do if the conversion fails? */
-      aacparse->ts = btime;
-    }
+  GstAudioChannelPosition *pos;
+  gboolean ret;
+  gboolean channel_map_failed;
+  GstCaps *caps;
+
+  /* store new negotiation information */
+  aacparse->samplerate = info->samplerate;
+  aacparse->channels = info->channels;
+  aacparse->object_type = info->object_type;
+  g_free (aacparse->channel_positions);
+  aacparse->channel_positions = g_memdup (info->channel_position, aacparse->channels);
+
+  if (aacparse->object_type == 5 && info->ps == 1) {
+      aacparse->object_type = 6;
   }
 
-  /* ADIF: only send an initial 0 timestamp downstream,
-   * then admit we have no idea and let downstream (decoder) handle it */
-  if (aacparse->header_type != DSPAAC_HEADER_ADIF || !aacparse->ts) {
-    GST_BUFFER_DURATION (buffer) = AAC_FRAME_DURATION (aacparse);
-    GST_BUFFER_TIMESTAMP (buffer) = aacparse->ts;
+  if (!aacparse->packetised) {
+      caps = gst_caps_new_simple ("audio/mpeg",
+        "mpegversion", G_TYPE_INT, 4,
+        "channels", G_TYPE_INT, aacparse->channels,
+        "rate", G_TYPE_INT, aacparse->samplerate,
+        "object_type", G_TYPE_INT, aacparse->object_type, NULL);
+  } else {
+      caps = gst_caps_new_simple ("audio/mpeg",
+        "mpegversion", G_TYPE_INT, 4,
+        "framed", G_TYPE_BOOLEAN, aacparse->packetised,
+        "codec_data", GST_TYPE_BUFFER, aacparse->codec_info,
+        "rate", G_TYPE_INT, aacparse->samplerate,
+        "channel", G_TYPE_INT, aacparse->channels,
+        "object_type", G_TYPE_INT, aacparse->object_type, NULL);
   }
 
-  if (GST_CLOCK_TIME_IS_VALID (aacparse->ts))
-    aacparse->ts += GST_BUFFER_DURATION (buffer);
+  aacparse->bps = 16 / 8;
 
-  if (!(++aacparse->framecount % 50)) {
-    gst_aacparse_update_duration (aacparse);
+  channel_map_failed = FALSE;
+  pos =
+      gst_aacparse_chanpos_to_gst (aacparse, aacparse->channel_positions, aacparse->channels,
+      &channel_map_failed);
+  if (channel_map_failed) {
+    GST_DEBUG_OBJECT (aacparse, "Could not map channel positions");
+    gst_caps_unref (caps);
+    return FALSE;
   }
-  aacparse->bytecount += GST_BUFFER_SIZE (buffer);
-
-  if (!aacparse->src_caps_set) {
-    if (!gst_aacparse_set_src_caps (aacparse,
-            GST_PAD_CAPS (GST_BASE_PARSE (aacparse)->sinkpad))) {
-      /* If linking fails, we need to return appropriate error */
-      ret = GST_FLOW_NOT_LINKED;
-    }
-    aacparse->src_caps_set = TRUE;
+  if (pos) {
+    gst_audio_set_channel_positions (gst_caps_get_structure (caps, 0), pos);
+    g_free (pos);
   }
 
-  gst_buffer_set_caps (buffer, GST_PAD_CAPS (parse->srcpad));
+  GST_DEBUG_OBJECT (aacparse, "New output caps: %" GST_PTR_FORMAT, caps);
+
+  ret = gst_pad_set_caps (aacparse->srcpad, caps);
+  gst_caps_unref (caps);
+
   return ret;
 }
 
-
-/**
- * gst_aacparse_start:
- * @parse: #GstBaseParse.
- *
- * Implementation of "start" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE if startup succeeded.
- */
-gboolean
-gst_aacparse_start (GstBaseParse * parse)
+static gboolean
+looks_like_valid_header (guint8 * input_data, guint input_size)
 {
-  GstAacParse *aacparse;
+  if (input_size < 4)
+    return FALSE;
 
-  aacparse = GST_AACPARSE (parse);
-  GST_DEBUG ("start");
-  aacparse->src_caps_set = FALSE;
-  aacparse->framecount = 0;
-  aacparse->bytecount = 0;
-  aacparse->ts = 0;
-  aacparse->sync = FALSE;
-  aacparse->eos = FALSE;
-  gst_base_parse_set_passthrough (parse, FALSE);
-  return TRUE;
-}
+  if (input_data[0] == 'A'
+      && input_data[1] == 'D' && input_data[2] == 'I' && input_data[3] == 'F')
+    /* ADIF type header */
+    return TRUE;
 
+  if (input_data[0] == 0xff && (input_data[1] >> 4) == 0xf)
+    /* ADTS type header */
+    return TRUE;
 
-/**
- * gst_aacparse_stop:
- * @parse: #GstBaseParse.
- *
- * Implementation of "stop" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE is stopping succeeded.
- */
-gboolean
-gst_aacparse_stop (GstBaseParse * parse)
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_aacparse_chain (GstPad * pad, GstBuffer * buffer)
 {
+  GstFlowReturn ret = GST_FLOW_OK;
+  guint input_size;
+  guint skip_bytes = 0;
+  guchar *input_data;
   GstAacParse *aacparse;
+  GstBuffer *outbuf;
+  faacDecFrameInfo info;
+  static gboolean fmt_change;
 
-  aacparse = GST_AACPARSE (parse);
-  GST_DEBUG ("stop");
-  aacparse->ts = -1;
-  return TRUE;
-}
+  aacparse = GST_AACPARSE (gst_pad_get_parent (pad));
 
+  if (GST_BUFFER_IS_DISCONT (buffer)) {
+    gst_aacparse_drain (aacparse);
+    faacDecPostSeekReset (aacparse->handle, 0);
+    aacparse->discont = TRUE;
+  }
 
-/**
- * gst_aacparse_event:
- * @parse: #GstBaseParse.
- * @event: #GstEvent.
- *
- * Implementation of "event" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE if the event was handled and can be dropped.
- */
-gboolean
-gst_aacparse_event (GstBaseParse * parse, GstEvent * event)
-{
-  GstAacParse *aacparse;
+  GST_OBJECT_LOCK (aacparse);
+  aacparse->bytes_in += GST_BUFFER_SIZE (buffer);
+  GST_OBJECT_UNLOCK (aacparse);
 
-  aacparse = GST_AACPARSE (parse);
-  GST_DEBUG ("event");
+  if (GST_BUFFER_TIMESTAMP (buffer) != GST_CLOCK_TIME_NONE) {
+    /* some demuxers send multiple buffers in a row
+     *  with the same timestamp (e.g. matroskademux) */
+    if (GST_BUFFER_TIMESTAMP (buffer) != aacparse->prev_ts) {
+      aacparse->next_ts = GST_BUFFER_TIMESTAMP (buffer);
+      aacparse->prev_ts = GST_BUFFER_TIMESTAMP (buffer);
+    }
+    GST_LOG_OBJECT (aacparse, "Timestamp on incoming buffer: %" GST_TIME_FORMAT
+        ", next_ts: %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+        GST_TIME_ARGS (aacparse->next_ts));
+  }
 
-  switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_EOS:
-      aacparse->eos = TRUE;
-      GST_DEBUG ("EOS event");
-      break;
-    default:
-      break;
+  input_data = GST_BUFFER_DATA (buffer);
+  input_size = GST_BUFFER_SIZE (buffer);
+
+  /* init if not already done during capsnego */
+  if (!aacparse->init) {
+#if FAAD2_MINOR_VERSION >= 7
+    unsigned long rate;
+#else
+    guint32 rate;
+#endif
+    guint8 ch;
+
+    GST_DEBUG_OBJECT (aacparse, "initialising ...");
+    /* We check if the first data looks like it might plausibly contain
+     * appropriate initialisation info... if not, we use our fake_codec_data
+     */
+    if (looks_like_valid_header (input_data, input_size) || !aacparse->packetised) {
+      if (faacDecInit (aacparse->handle, input_data, input_size, &rate, &ch) < 0)
+        goto init_failed;
+
+      GST_DEBUG_OBJECT (aacparse, "faacDecInit() ok: rate=%u,channels=%u", rate,
+          ch);
+    } else {
+      if ((gint8) faacDecInit2 (aacparse->handle, aacparse->fake_codec_data, 2,
+              &rate, &ch) < 0) {
+        goto init2_failed;
+      }
+      GST_DEBUG_OBJECT (aacparse, "faacDecInit2() ok: rate=%u,channels=%u", rate,
+          ch);
+    }
+
+    skip_bytes = 0;
+    fmt_change = FALSE;
+    aacparse->init = TRUE;
+
+    /* make sure we create new caps below */
+    aacparse->samplerate = 0;
+    aacparse->channels = 0;
+    gst_aacparse_send_tags (aacparse);
   }
 
-  return parent_class->event (parse, event);
-}
+  if (!fmt_change) {
+    faacDecDecode (aacparse->handle, &info, input_data, input_size);
+        if (info.samplerate != aacparse->samplerate ||
+            info.channels != aacparse->channels) {
+            if (!gst_aacparse_update_caps (aacparse, &info)) {
+            GST_ELEMENT_ERROR (aacparse, CORE, NEGOTIATION, (NULL),
+                ("Setting caps on source pad failed"));
+            ret = GST_FLOW_ERROR;
+            goto out;
+            } else {
+                fmt_change = TRUE;
+            }
+        }
+    }
+
+  if (aacparse->discont) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    aacparse->discont = FALSE;
+  }
 
+  ret =
+    gst_pad_alloc_buffer_and_set_caps (aacparse->srcpad, 0, GST_BUFFER_SIZE (buffer),
+    GST_PAD_CAPS (aacparse->srcpad), &outbuf);
+  if (ret != GST_FLOW_OK)
+    goto out;
 
-/**
- * gst_aacparse_convert:
- * @parse: #GstBaseParse.
- * @src_format: #GstFormat describing the source format.
- * @src_value: Source value to be converted.
- * @dest_format: #GstFormat defining the converted format.
- * @dest_value: Pointer where the conversion result will be put.
- *
- * Implementation of "convert" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE if conversion was successful.
- */
-gboolean
-gst_aacparse_convert (GstBaseParse * parse,
-    GstFormat src_format,
-    gint64 src_value, GstFormat dest_format, gint64 * dest_value)
+   memcpy (GST_BUFFER_DATA (outbuf), GST_BUFFER_DATA (buffer), GST_BUFFER_SIZE (buffer));
+
+  ret = gst_pad_push (aacparse->srcpad, outbuf);
+
+out:
+
+  gst_buffer_unref (buffer);
+  gst_object_unref (aacparse);
+
+  return ret;
+
+/* ERRORS */
+init_failed:
+  {
+    GST_ELEMENT_ERROR (aacparse, STREAM, DECODE, (NULL),
+        ("Failed to init decoder from stream"));
+    ret = GST_FLOW_ERROR;
+    goto out;
+  }
+init2_failed:
+  {
+    GST_ELEMENT_ERROR (aacparse, STREAM, DECODE, (NULL),
+        ("%s() failed", (aacparse->handle) ? "faacDecInit2" : "faacDecOpen"));
+    ret = GST_FLOW_ERROR;
+    goto out;
+  }
+}
+
+static gboolean
+gst_aacparse_open_decoder (GstAacParse * aacparse)
 {
-  gboolean ret = FALSE;
-  GstAacParse *aacparse;
-  gfloat bpf;
+  faacDecConfiguration *conf;
 
-  aacparse = GST_AACPARSE (parse);
+  aacparse->handle = faacDecOpen ();
 
-  /* We are not able to do any estimations until some data has been passed */
-  if (!aacparse->framecount)
+  if (aacparse->handle == NULL) {
+    GST_WARNING_OBJECT (aacparse, "faacDecOpen() failed");
     return FALSE;
+  }
 
-  bpf = (gfloat) aacparse->bytecount / aacparse->framecount;
-
-  if (src_format == GST_FORMAT_BYTES) {
-    if (dest_format == GST_FORMAT_TIME) {
-      /* BYTES -> TIME conversion */
-      GST_DEBUG ("converting bytes -> time");
+  conf = faacDecGetCurrentConfiguration (aacparse->handle);
+  conf->defObjectType = LC;
+  conf->dontUpSampleImplicitSBR = 1;
+  conf->outputFormat = FAAD_FMT_16BIT;
 
-      if (aacparse->framecount && aacparse->frames_per_sec) {
-        *dest_value = AAC_FRAME_DURATION (aacparse) * src_value / bpf;
-        GST_DEBUG ("conversion result: %" G_GINT64_FORMAT " ms",
-            *dest_value / GST_MSECOND);
-        ret = TRUE;
-      }
-    } else if (dest_format == GST_FORMAT_BYTES) {
-      /* Parent class may ask us to convert from BYTES to BYTES */
-      *dest_value = src_value;
-      ret = TRUE;
-    }
-  } else if (src_format == GST_FORMAT_TIME) {
-    GST_DEBUG ("converting time -> bytes");
-    if (dest_format == GST_FORMAT_BYTES) {
-      if (aacparse->framecount && aacparse->frames_per_sec) {
-        *dest_value = bpf * src_value / AAC_FRAME_DURATION (aacparse);
-        GST_DEBUG ("time %" G_GINT64_FORMAT " ms in bytes = %" G_GINT64_FORMAT,
-            src_value / GST_MSECOND, *dest_value);
-        ret = TRUE;
-      }
-    }
-  } else if (src_format == GST_FORMAT_DEFAULT) {
-    /* DEFAULT == frame-based */
-    if (dest_format == GST_FORMAT_TIME && aacparse->frames_per_sec) {
-      *dest_value = src_value * AAC_FRAME_DURATION (aacparse);
-      ret = TRUE;
-    } else if (dest_format == GST_FORMAT_BYTES) {
-    }
+  if (faacDecSetConfiguration (aacparse->handle, conf) == 0) {
+    GST_WARNING_OBJECT (aacparse, "faacDecSetConfiguration() failed");
+    return FALSE;
   }
 
-  return ret;
+  return TRUE;
 }
 
+static void
+gst_aacparse_close_decoder (GstAacParse * aacparse)
+{
+  if (aacparse->handle) {
+    faacDecClose (aacparse->handle);
+    aacparse->handle = NULL;
+  }
+}
 
-/**
- * gst_aacparse_is_seekable:
- * @parse: #GstBaseParse.
- *
- * Implementation of "is_seekable" vmethod in #GstBaseParse class.
- *
- * Returns: TRUE if the current stream is seekable.
- */
-gboolean
-gst_aacparse_is_seekable (GstBaseParse * parse)
+static GstStateChangeReturn
+gst_aacparse_change_state (GstElement * element, GstStateChange transition)
 {
-  GstAacParse *aacparse;
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstAacParse *aacparse = GST_AACPARSE (element);
 
-  aacparse = GST_AACPARSE (parse);
-  GST_DEBUG_OBJECT (aacparse, "IS_SEEKABLE: %d",
-      aacparse->header_type != DSPAAC_HEADER_ADIF);
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!gst_aacparse_open_decoder (aacparse))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_segment_init (aacparse->segment, GST_FORMAT_TIME);
+      break;
+    default:
+      break;
+  }
 
-  /* Not seekable if ADIF header is found */
-  return (aacparse->header_type != DSPAAC_HEADER_ADIF);
-}
+  if (GST_ELEMENT_CLASS (parent_class)->change_state)
+    ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      aacparse->samplerate = -1;
+      aacparse->channels = -1;
+      aacparse->need_channel_setup = TRUE;
+      aacparse->init = FALSE;
+      g_free (aacparse->channel_positions);
+      aacparse->channel_positions = NULL;
+      aacparse->next_ts = 0;
+      aacparse->prev_ts = GST_CLOCK_TIME_NONE;
+      aacparse->bytes_in = 0;
+      aacparse->sum_dur_out = 0;
+      aacparse->error_count = 0;
+      clear_queued (aacparse);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_aacparse_close_decoder (aacparse);
+      break;
+    default:
+      break;
+  }
 
+  return ret;
+}
 
-/**
- * plugin_init:
- * @plugin: GstPlugin
- *
- * Returns: TRUE on success.
- */
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  return gst_element_register (plugin, "aacparse",
-      GST_RANK_NONE, GST_TYPE_AACPARSE);
+  return gst_element_register (plugin, "aacparse", GST_RANK_PRIMARY, GST_TYPE_AACPARSE);
 }
 
-
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
     "aacparse",
-    "Advanced Audio Coding Parser",
-    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN);
+    "AAC Parser",
+    plugin_init, VERSION, "GPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/aacparse/gstaacparse.h b/gst/aacparse/gstaacparse.h
index bbdbebc..9ac2250 100644
--- a/gst/aacparse/gstaacparse.h
+++ b/gst/aacparse/gstaacparse.h
@@ -23,94 +23,72 @@
 #define __GST_AACPARSE_H__
 
 #include <gst/gst.h>
-#include "gstbaseparse.h"
+#include <gst/base/gstadapter.h>
+#ifdef FAAD_IS_NEAAC
+#include <neaacdec.h>
+#else
+#include <faad.h>
+#endif
 
 G_BEGIN_DECLS
 
 #define GST_TYPE_AACPARSE \
-  (gst_aacparse_get_type())
+  (gst_aacparse_get_type ())
 #define GST_AACPARSE(obj) \
-  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AACPARSE, GstAacParse))
+  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AACPARSE, GstAacParse))
 #define GST_AACPARSE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AACPARSE, GstAacParseClass))
+  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AACPARSE, GstAacParseClass))
 #define GST_IS_AACPARSE(obj) \
-  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AACPARSE))
+  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AACPARSE))
 #define GST_IS_AACPARSE_CLASS(klass) \
-  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AACPARSE))
-
-
-/**
- * GstAacHeaderType:
- * @DSPAAC_HEADER_NOT_PARSED: Header not parsed yet.
- * @DSPAAC_HEADER_UNKNOWN: Unknown (not recognized) header.
- * @DSPAAC_HEADER_ADIF: ADIF header found.
- * @DSPAAC_HEADER_ADTS: ADTS header found.
- * @DSPAAC_HEADER_NONE: Raw stream, no header.
- *
- * Type header enumeration set in #header_type.
- */
-typedef enum {
-  DSPAAC_HEADER_NOT_PARSED,
-  DSPAAC_HEADER_UNKNOWN,
-  DSPAAC_HEADER_ADIF,
-  DSPAAC_HEADER_ADTS,
-  DSPAAC_HEADER_NONE
-} GstAacHeaderType;
-
-
-typedef struct _GstAacParse GstAacParse;
-typedef struct _GstAacParseClass GstAacParseClass;
-
-/**
- * GstAacParse:
- * @element: the parent element.
- * @object_type: AAC object type of the stream.
- * @bitrate:  Current media bitrate.
- * @sample_rate: Current media samplerate.
- * @channels: Current media channel count.
- * @frames_per_sec: FPS value of the current stream.
- * @header_type: #GstAacHeaderType indicating the current stream type.
- * @framecount: The amount of frames that has been processed this far.
- * @bytecount: The amount of bytes that has been processed this far.
- * @sync: Tells whether the parser is in sync (a.k.a. not searching for header)
- * @eos: End-of-Stream indicator. Set when EOS event arrives.
- * @duration: Duration of the current stream.
- * @ts: Current stream timestamp.
- *
- * The opaque GstAacParse data structure.
- */
-struct _GstAacParse {
-  GstBaseParse element;
-
-  /* Stream type -related info */
-  gint           object_type;
-  gint           bitrate;
-  gint           sample_rate;
-  gint           channels;
-  gint           mpegversion;
-  gfloat         frames_per_sec;
-
-  GstAacHeaderType header_type;
-
-  guint64 framecount;
-  guint64 bytecount;
-  gboolean src_caps_set;
-  gboolean sync;
-  gboolean eos;
-
-  GstClockTime duration;
-  GstClockTime ts;
-};
-
-/**
- * GstAacParseClass:
- * @parent_class: Element parent class.
- *
- * The opaque GstAacParseClass data structure.
- */
-struct _GstAacParseClass {
-  GstBaseParseClass parent_class;
-};
+  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AACPARSE))
+
+typedef struct _GstAacParse {
+  GstElement element;
+  GstAdapter *adapter;
+
+  GstPad    *srcpad;
+  GstPad    *sinkpad;
+
+  guint      samplerate;  /* sample rate of the last MPEG frame    */
+  guint      channels;    /* number of channels of the last frame  */
+  guint      bps;         /* bytes per sample                      */
+  guint      object_type; /* object type of the stream */
+  guint      ps;          /* eAAC+ file */
+
+  guint8     fake_codec_data[2];
+  GstBuffer *codec_info;
+  gboolean   flushing;
+
+  /* FAAD object */
+  faacDecHandle handle;
+  gboolean init;
+
+  /* FAAD channel setup */
+  guchar *channel_positions;
+  gboolean need_channel_setup;
+  gboolean packetised; /* We must differentiate between raw and packetised streams */
+
+  gint64  prev_ts;     /* timestamp of previous buffer                    */
+  gint64  next_ts;     /* timestamp of next buffer                        */
+  guint64 bytes_in;    /* bytes received                                  */
+  guint64 sum_dur_out; /* sum of durations of decoded buffers we sent out */
+  gint    error_count;
+  gboolean discont;
+
+  /* segment handling */
+  GstSegment * segment;
+
+  /* list of raw output buffers for reverse playback */
+  GList *queued;
+  /* gather/decode queues for reverse playback */
+  GList *gather;
+  GList *decode;
+} GstAacParse;
+
+typedef struct _GstAacParseClass {
+  GstElementClass parent_class;
+} GstAacParseClass;
 
 GType gst_aacparse_get_type (void);
 
-- 
1.6.3.1

