From acfc8d99744f4b0f35ea1a3caa4ecc6413715495 Mon Sep 17 00:00:00 2001
From: Roberto Castaneda <rsheissa@ti.com>
Date: Thu, 3 Dec 2009 17:43:48 -0600
Subject: [PATCH 2/2] aacparse: Add framed caps, increse rank.

Signed-off-by: Daniel Diaz <ddiaz@ti.com>
---
 gst/aacparse/gstaacparse.c |  180 ++++++++++++++++++++++++++++----------------
 1 files changed, 116 insertions(+), 64 deletions(-)

diff --git a/gst/aacparse/gstaacparse.c b/gst/aacparse/gstaacparse.c
index f1e7a5b..ea90b5a 100644
--- a/gst/aacparse/gstaacparse.c
+++ b/gst/aacparse/gstaacparse.c
@@ -76,7 +76,7 @@ GST_DEBUG_CATEGORY_STATIC (aacparse_debug);
 #define MAX_DECODE_ERRORS 5
 
 static const GstElementDetails aacparse_details =
-GST_ELEMENT_DETAILS ("AAC audio decoder",
+GST_ELEMENT_DETAILS ("Parser based on AAC audio decoder",
     "Codec/Decoder/Audio",
     "Free MPEG-2/4 AAC decoder",
     "Ronald Bultje <rbultje@ronald.bitfreak.net>");
@@ -84,7 +84,8 @@ GST_ELEMENT_DETAILS ("AAC audio decoder",
 static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/mpeg, " "mpegversion = (int) { 2, 4 }")
+    GST_STATIC_CAPS ("audio/mpeg, " "mpegversion = (int) { 2, 4 }, "
+        "parsed = (boolean) false")
     );
 
 #define STATIC_INT_CAPS(bpp) \
@@ -92,7 +93,8 @@ static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
     "mpegversion = (int) 4, " \
     "channels = (int) [ 1, 2 ], " \
     "rate = (int) [ 8000, 96000 ], " \
-    "object_type = (int) [ 1, 6 ]"
+    "object_type = (int) [ 1, 6 ], " \
+    "parsed = (boolean) true"
 
 
 /*
@@ -126,8 +128,9 @@ static gboolean gst_aacparse_src_query (GstPad * pad, GstQuery * query);
 static GstFlowReturn gst_aacparse_chain (GstPad * pad, GstBuffer * buffer);
 static GstStateChangeReturn gst_aacparse_change_state (GstElement * element,
     GstStateChange transition);
-static gboolean gst_aacparse_src_convert (GstAacParse * aacparse, GstFormat src_format,
-    gint64 src_val, GstFormat dest_format, gint64 * dest_val);
+static gboolean gst_aacparse_src_convert (GstAacParse * aacparse,
+    GstFormat src_format, gint64 src_val, GstFormat dest_format,
+    gint64 * dest_val);
 static gboolean gst_aacparse_open_decoder (GstAacParse * aacparse);
 static void gst_aacparse_close_decoder (GstAacParse * aacparse);
 
@@ -183,7 +186,8 @@ gst_aacparse_class_init (GstAacParseClass * klass)
 
   gobject_class->dispose = GST_DEBUG_FUNCPTR (gst_aacparse_dispose);
 
-  gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_aacparse_change_state);
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_aacparse_change_state);
 }
 
 static void
@@ -325,12 +329,12 @@ gst_aacparse_setcaps (GstPad * pad, GstCaps * caps)
     if (channels != ((cdata[1] & 0x78) >> 3)) {
       /* https://bugs.launchpad.net/ubuntu/+source/faad2/+bug/290259 */
       GST_WARNING_OBJECT (aacparse,
-          "buggy aacparse version, wrong number of channels %d instead of %d", channels,
-          ((cdata[1] & 0x78) >> 3));
+          "buggy aacparse version, wrong number of channels %d instead of %d",
+          channels, ((cdata[1] & 0x78) >> 3));
     }
 
-    GST_DEBUG_OBJECT (aacparse, "codec_data init: channels=%u, rate=%u", channels,
-        samplerate);
+    GST_DEBUG_OBJECT (aacparse, "codec_data init: channels=%u, rate=%u",
+        channels, samplerate);
 
     /* not updating these here, so they are updated in the
      * chain function, and new caps are created etc. */
@@ -359,10 +363,11 @@ gst_aacparse_setcaps (GstPad * pad, GstCaps * caps)
       profile = 3;              /* 0=MAIN, 1=LC, 2=SSR, 3=LTP */
       rate_idx = aac_rate_idx (rate);
 
-      aacparse->fake_codec_data[0] = ((profile + 1) << 3) | ((rate_idx & 0xE) >> 1);
+      aacparse->fake_codec_data[0] =
+          ((profile + 1) << 3) | ((rate_idx & 0xE) >> 1);
       aacparse->fake_codec_data[1] = ((rate_idx & 0x1) << 7) | (channels << 3);
-      GST_LOG_OBJECT (aacparse, "created fake codec data (%u,%u): 0x%x 0x%x", rate,
-          channels, (int) aacparse->fake_codec_data[0],
+      GST_LOG_OBJECT (aacparse, "created fake codec data (%u,%u): 0x%x 0x%x",
+          rate, channels, (int) aacparse->fake_codec_data[0],
           (int) aacparse->fake_codec_data[1]);
     }
   }
@@ -400,11 +405,13 @@ gst_aacparse_chanpos_to_gst (GstAacParse * aacparse, guchar * fpos, guint num,
 
   /* special handling for the common cases for mono and stereo */
   if (num == 1 && fpos[0] == FRONT_CHANNEL_CENTER) {
-    GST_DEBUG_OBJECT (aacparse, "mono common case; won't set channel positions");
+    GST_DEBUG_OBJECT (aacparse,
+        "mono common case; won't set channel positions");
     return NULL;
   } else if (num == 2 && fpos[0] == FRONT_CHANNEL_LEFT
       && fpos[1] == FRONT_CHANNEL_RIGHT) {
-    GST_DEBUG_OBJECT (aacparse, "stereo common case; won't set channel positions");
+    GST_DEBUG_OBJECT (aacparse,
+        "stereo common case; won't set channel positions");
     return NULL;
   }
 
@@ -496,7 +503,8 @@ gst_aacparse_srcgetcaps (GstPad * pad)
     g_free (supported_fpos);
   }
 
-  if (aacparse->handle != NULL && aacparse->channels != -1 && aacparse->samplerate != -1) {
+  if (aacparse->handle != NULL && aacparse->channels != -1
+      && aacparse->samplerate != -1) {
     GstCaps *caps = gst_caps_new_empty ();
     GstStructure *str;
     gint fmt[] = {
@@ -525,21 +533,24 @@ gst_aacparse_srcgetcaps (GstPad * pad)
       }
 
       if (aacparse->object_type > 0) {
-          gst_structure_set (str, "object_type", G_TYPE_INT, aacparse->object_type, NULL);
+        gst_structure_set (str, "object_type", G_TYPE_INT,
+            aacparse->object_type, NULL);
       } else {
-          gst_structure_set (str, "object_type", GST_TYPE_INT_RANGE, 1, 6, NULL);
+        gst_structure_set (str, "object_type", GST_TYPE_INT_RANGE, 1, 6, NULL);
       }
 
       if (aacparse->channels > 0) {
-        gst_structure_set (str, "channels", G_TYPE_INT, aacparse->channels, NULL);
+        gst_structure_set (str, "channels", G_TYPE_INT, aacparse->channels,
+            NULL);
 
         /* put channel information here */
         if (aacparse->channel_positions) {
           GstAudioChannelPosition *pos;
           gboolean map_failed;
 
-          pos = gst_aacparse_chanpos_to_gst (aacparse, aacparse->channel_positions,
-              aacparse->channels, &map_failed);
+          pos =
+              gst_aacparse_chanpos_to_gst (aacparse,
+              aacparse->channel_positions, aacparse->channels, &map_failed);
           if (map_failed) {
             gst_structure_free (str);
             continue;
@@ -556,6 +567,7 @@ gst_aacparse_srcgetcaps (GstPad * pad)
         gst_structure_set (str, "channels", GST_TYPE_INT_RANGE, 1, 8, NULL);
         /* we set channel positions later */
       }
+      gst_structure_set (str, "parsed", G_TYPE_BOOLEAN, TRUE, NULL);
 
       gst_caps_append_structure (caps, str);
     }
@@ -717,8 +729,8 @@ gst_aacparse_sink_event (GstPad * pad, GstEvent * event)
         GST_DEBUG ("Got NEWSEGMENT event in GST_FORMAT_TIME, passing on (%"
             GST_TIME_FORMAT " - %" GST_TIME_FORMAT ")", GST_TIME_ARGS (start),
             GST_TIME_ARGS (end));
-        gst_segment_set_newsegment (aacparse->segment, is_update, rate, fmt, start,
-            end, base);
+        gst_segment_set_newsegment (aacparse->segment, is_update, rate, fmt,
+            start, end, base);
       } else if (fmt == GST_FORMAT_BYTES) {
         gint64 new_start = 0;
         gint64 new_end = -1;
@@ -765,8 +777,8 @@ gst_aacparse_sink_event (GstPad * pad, GstEvent * event)
 }
 
 static gboolean
-gst_aacparse_src_convert (GstAacParse * aacparse, GstFormat src_format, gint64 src_val,
-    GstFormat dest_format, gint64 * dest_val)
+gst_aacparse_src_convert (GstAacParse * aacparse, GstFormat src_format,
+    gint64 src_val, GstFormat dest_format, gint64 * dest_val)
 {
   guint64 bytes_in, time_out, val;
 
@@ -832,7 +844,8 @@ gst_aacparse_src_query (GstPad * pad, GstQuery * query)
 
       format = GST_FORMAT_BYTES;
       if (!gst_pad_query_duration (peer, &format, &len_bytes)) {
-        GST_DEBUG_OBJECT (aacparse, "query failed: failed to get upstream length");
+        GST_DEBUG_OBJECT (aacparse,
+            "query failed: failed to get upstream length");
         break;
       }
 
@@ -908,34 +921,37 @@ gst_aacparse_update_caps (GstAacParse * aacparse, faacDecFrameInfo * info)
   aacparse->channels = info->channels;
   aacparse->object_type = info->object_type;
   g_free (aacparse->channel_positions);
-  aacparse->channel_positions = g_memdup (info->channel_position, aacparse->channels);
+  aacparse->channel_positions =
+      g_memdup (info->channel_position, aacparse->channels);
 
   if (aacparse->object_type == 5 && info->ps == 1) {
-      aacparse->object_type = 6;
+    aacparse->object_type = 6;
   }
 
   if (!aacparse->packetised) {
-      caps = gst_caps_new_simple ("audio/mpeg",
+    caps = gst_caps_new_simple ("audio/mpeg",
         "mpegversion", G_TYPE_INT, 4,
         "channels", G_TYPE_INT, aacparse->channels,
         "rate", G_TYPE_INT, aacparse->samplerate,
-        "object_type", G_TYPE_INT, aacparse->object_type, NULL);
+        "object_type", G_TYPE_INT, aacparse->object_type,
+        "parsed", G_TYPE_BOOLEAN, TRUE, NULL);
   } else {
-      caps = gst_caps_new_simple ("audio/mpeg",
+    caps = gst_caps_new_simple ("audio/mpeg",
         "mpegversion", G_TYPE_INT, 4,
-        "framed", G_TYPE_BOOLEAN, aacparse->packetised,
-        "codec_data", GST_TYPE_BUFFER, aacparse->codec_info,
+        "channels", G_TYPE_INT, aacparse->channels,
         "rate", G_TYPE_INT, aacparse->samplerate,
-        "channel", G_TYPE_INT, aacparse->channels,
-        "object_type", G_TYPE_INT, aacparse->object_type, NULL);
+        "object_type", G_TYPE_INT, aacparse->object_type,
+        "parsed", G_TYPE_BOOLEAN, TRUE,
+        "framed", G_TYPE_BOOLEAN, aacparse->packetised,
+        "codec_data", GST_TYPE_BUFFER, aacparse->codec_info, NULL);
   }
 
   aacparse->bps = 16 / 8;
 
   channel_map_failed = FALSE;
   pos =
-      gst_aacparse_chanpos_to_gst (aacparse, aacparse->channel_positions, aacparse->channels,
-      &channel_map_failed);
+      gst_aacparse_chanpos_to_gst (aacparse, aacparse->channel_positions,
+      aacparse->channels, &channel_map_failed);
   if (channel_map_failed) {
     GST_DEBUG_OBJECT (aacparse, "Could not map channel positions");
     gst_caps_unref (caps);
@@ -977,7 +993,9 @@ gst_aacparse_chain (GstPad * pad, GstBuffer * buffer)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   guint input_size;
+  guint bufsize = 0;
   guint skip_bytes = 0;
+  guint num_samples = 0;
   guchar *input_data;
   GstAacParse *aacparse;
   GstBuffer *outbuf;
@@ -1025,8 +1043,10 @@ gst_aacparse_chain (GstPad * pad, GstBuffer * buffer)
     /* We check if the first data looks like it might plausibly contain
      * appropriate initialisation info... if not, we use our fake_codec_data
      */
-    if (looks_like_valid_header (input_data, input_size) || !aacparse->packetised) {
-      if (faacDecInit (aacparse->handle, input_data, input_size, &rate, &ch) < 0)
+    if (looks_like_valid_header (input_data, input_size)
+        || !aacparse->packetised) {
+      if (faacDecInit (aacparse->handle, input_data, input_size, &rate,
+              &ch) < 0)
         goto init_failed;
 
       GST_DEBUG_OBJECT (aacparse, "faacDecInit() ok: rate=%u,channels=%u", rate,
@@ -1036,8 +1056,8 @@ gst_aacparse_chain (GstPad * pad, GstBuffer * buffer)
               &rate, &ch) < 0) {
         goto init2_failed;
       }
-      GST_DEBUG_OBJECT (aacparse, "faacDecInit2() ok: rate=%u,channels=%u", rate,
-          ch);
+      GST_DEBUG_OBJECT (aacparse, "faacDecInit2() ok: rate=%u,channels=%u",
+          rate, ch);
     }
 
     skip_bytes = 0;
@@ -1052,33 +1072,63 @@ gst_aacparse_chain (GstPad * pad, GstBuffer * buffer)
 
   if (!fmt_change) {
     faacDecDecode (aacparse->handle, &info, input_data, input_size);
-        if (info.samplerate != aacparse->samplerate ||
-            info.channels != aacparse->channels) {
-            if (!gst_aacparse_update_caps (aacparse, &info)) {
-            GST_ELEMENT_ERROR (aacparse, CORE, NEGOTIATION, (NULL),
-                ("Setting caps on source pad failed"));
-            ret = GST_FLOW_ERROR;
-            goto out;
-            } else {
-                fmt_change = TRUE;
-            }
-        }
+    if (info.samplerate != aacparse->samplerate ||
+        info.channels != aacparse->channels) {
+      if (!gst_aacparse_update_caps (aacparse, &info)) {
+        GST_ELEMENT_ERROR (aacparse, CORE, NEGOTIATION, (NULL),
+            ("Setting caps on source pad failed"));
+        ret = GST_FLOW_ERROR;
+        goto out;
+      } else {
+        fmt_change = TRUE;
+      }
     }
-
-  if (aacparse->discont) {
-    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
-    aacparse->discont = FALSE;
   }
 
-  ret =
-    gst_pad_alloc_buffer_and_set_caps (aacparse->srcpad, 0, GST_BUFFER_SIZE (buffer),
-    GST_PAD_CAPS (aacparse->srcpad), &outbuf);
-  if (ret != GST_FLOW_OK)
-    goto out;
 
-   memcpy (GST_BUFFER_DATA (outbuf), GST_BUFFER_DATA (buffer), GST_BUFFER_SIZE (buffer));
+  {
+    bufsize = info.samples * aacparse->bps;
+    num_samples = info.samples / aacparse->channels;
+
+    ret =
+        gst_pad_alloc_buffer_and_set_caps (aacparse->srcpad, 0,
+        GST_BUFFER_SIZE (buffer), GST_PAD_CAPS (aacparse->srcpad), &outbuf);
+
+    if (ret != GST_FLOW_OK)
+      goto out;
+
+    memcpy (GST_BUFFER_DATA (outbuf), GST_BUFFER_DATA (buffer),
+        GST_BUFFER_SIZE (buffer));
+
+    GST_BUFFER_OFFSET (outbuf) =
+        GST_CLOCK_TIME_TO_FRAMES (aacparse->next_ts, aacparse->samplerate);
+    GST_BUFFER_TIMESTAMP (outbuf) = aacparse->next_ts;
+    GST_BUFFER_DURATION (outbuf) =
+        GST_FRAMES_TO_CLOCK_TIME (num_samples, aacparse->samplerate);
+
+    GST_LOG_OBJECT (aacparse,
+        "buffer, off=%" G_GUINT64_FORMAT ", ts=%" GST_TIME_FORMAT,
+        GST_BUFFER_OFFSET (outbuf),
+        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (outbuf)));
+    GST_LOG_OBJECT (aacparse, "duration=%" GST_TIME_FORMAT,
+        "next_ts=%" GST_TIME_FORMAT,
+        GST_TIME_ARGS (GST_BUFFER_DURATION (outbuf)),
+        GST_TIME_ARGS (aacparse->next_ts));
+    GST_OBJECT_LOCK (aacparse);
+    aacparse->next_ts += GST_BUFFER_DURATION (outbuf);
+    aacparse->sum_dur_out += GST_BUFFER_DURATION (outbuf);
+    GST_OBJECT_UNLOCK (aacparse);
+
+    if (aacparse->discont) {
+      GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+      aacparse->discont = FALSE;
+    }
+
+    ret = gst_pad_push (aacparse->srcpad, outbuf);
 
-  ret = gst_pad_push (aacparse->srcpad, outbuf);
+    if (ret != GST_FLOW_OK)
+      goto out;
+  }
 
 out:
 
@@ -1187,7 +1237,9 @@ gst_aacparse_change_state (GstElement * element, GstStateChange transition)
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  return gst_element_register (plugin, "aacparse", GST_RANK_PRIMARY, GST_TYPE_AACPARSE);
+  /* Increasing rank to be chosen first by PLAYBIN or PLAYBIN2. */
+  return gst_element_register (plugin, "aacparse", GST_RANK_PRIMARY + 1,
+      GST_TYPE_AACPARSE);
 }
 
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
-- 
1.6.3.1

