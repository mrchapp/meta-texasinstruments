From 47e6f0518150052f3e84cc8454bc64976a0543fb Mon Sep 17 00:00:00 2001
From: =?utf-8?q?V=C3=ADctor=20Manuel=20J=C3=A1quez=20Leal?= <vjaquez@igalia.com>
Date: Wed, 19 Aug 2009 13:32:54 +0200
Subject: [PATCH 2/2] jpegparse: This is a combination of 41 commits.

The 41 commits are:
* jpegparse: dettach it from the jpeg plugin
* jpegparse: remove the < 0.10.24 compatibility code
* jpegparse: change src pad capabilities
* jpegparse: caps in source pad are dynamically set
* jpegparse: header parse and caps handling
* jpegparse: add progressive field in caps
* jpegparse: reset params at pipeline stop
* jpegparse: don't impose image size
* jpegparse: add the progressive field in the static pad and reset params.
* jpegparse: add color format field in caps
* jpegparse: initial sink pad caps negotiation
* jpegparse: handling framerate
* jpegparse: decrease the marker length size to 4 (6-2)
* jpegparse: error handling.
* jpegparse: the attributes are initialized at change state
* jpegparse: documentation
* jpegparse: decrease the marker length
* jpegparse: Use interlaced caps instead of progressive according to bug 163577
* jpegparse: add the parsed property in the caps template
* jpegpaser: use small caps for init macro (common practice)
* jpegparse: change the dispose method for finalize
* jpegparse: fix the old/new caps comparation
* jpegparse: use a private structure
* jpgeparse: remove src event handler
* jpegparse: remove global reference to sinkpad
* jpegparse: remove redefinition of parent_class
* jpeparse: include defines for jpeg markers
* jpegparse: header parsing improvement
* jpegparse: use defines for markers in legacy code
* jpegparse: change from finalize to dispose
* jpegparse: don't assume a packet if the framerate is set
* jpegparse: add parse caps in src pad
* jpegparse: new function.
* jpegparse: add the parsed color formats.
* jpegparse: new new_segment private member
* jpegparse: use the first buffer's timestamp
* jpegparse: simplify the setcaps operation in chain
* jpegparse: silence compiler
* jpegparse: fix DRI section reading
* jpegparse: make DRI reading a single operation
* jpegparse: refactor the sof parsing
---
 docs/plugins/Makefile.am                          |    1 +
 docs/plugins/gst-plugins-bad-plugins-docs.sgml    |    2 +
 docs/plugins/gst-plugins-bad-plugins-sections.txt |   14 +
 gst/jpegparse/gstjpegparse.c                      |  567 ++++++++++++++++-----
 gst/jpegparse/gstjpegparse.h                      |   13 +-
 5 files changed, 461 insertions(+), 136 deletions(-)

diff --git a/docs/plugins/Makefile.am b/docs/plugins/Makefile.am
index 31a0bd9..6a9c35f 100644
--- a/docs/plugins/Makefile.am
+++ b/docs/plugins/Makefile.am
@@ -142,6 +142,7 @@ EXTRA_HFILES = \
 	$(top_srcdir)/gst/festival/gstfestival.h \
 	$(top_srcdir)/gst/legacyresample/gstlegacyresample.h \
 	$(top_srcdir)/gst/liveadder/liveadder.h \
+	$(top_srcdir)/gst/jpegparse/gstjpegparse.h \
 	$(top_srcdir)/gst/mxf/mxfdemux.h \
 	$(top_srcdir)/gst/mxf/mxfmux.h \
 	$(top_srcdir)/gst/nuvdemux/gstnuvdemux.h \
diff --git a/docs/plugins/gst-plugins-bad-plugins-docs.sgml b/docs/plugins/gst-plugins-bad-plugins-docs.sgml
index 98bdd82..89f9355 100644
--- a/docs/plugins/gst-plugins-bad-plugins-docs.sgml
+++ b/docs/plugins/gst-plugins-bad-plugins-docs.sgml
@@ -47,6 +47,7 @@
     <xi:include href="xml/element-ivorbisdec.xml" />
     <xi:include href="xml/element-jackaudiosrc.xml" />
     <xi:include href="xml/element-jackaudiosink.xml" />
+    <xi:include href="xml/element-jpegparse.xml" />
     <xi:include href="xml/element-kateenc.xml" />
     <xi:include href="xml/element-katedec.xml" />
     <xi:include href="xml/element-kateparse.xml" />
@@ -126,6 +127,7 @@
     <xi:include href="xml/plugin-gsm.xml" />
     <xi:include href="xml/plugin-h264parse.xml" />
     <xi:include href="xml/plugin-jack.xml" />
+    <xi:include href="xml/plugin-jpegparse.xml" />
     <xi:include href="xml/plugin-kate.xml" />
     <xi:include href="xml/plugin-ladspa.xml" />
     <xi:include href="xml/plugin-liveadder.xml" />
diff --git a/docs/plugins/gst-plugins-bad-plugins-sections.txt b/docs/plugins/gst-plugins-bad-plugins-sections.txt
index be12d1d..8b08ca4 100644
--- a/docs/plugins/gst-plugins-bad-plugins-sections.txt
+++ b/docs/plugins/gst-plugins-bad-plugins-sections.txt
@@ -486,6 +486,20 @@ gst_jack_audio_sink_get_type
 </SECTION>
 
 <SECTION>
+<FILE>element-jpegparse</FILE>
+<TITLE>jpegparse</TITLE>
+GstJpegParse
+<SUBSECTION Starndard>
+GstJpegParseClass
+GST_JPEG_PARSE
+GST_JPEG_PARSE_CLASS
+GST_IS_JPEG_PARSE
+GST_IS_JPEG_PARSE_CLASS
+GST_TYPE_JPEG_PARSE
+gst_jpeg_parse_get_type
+</SECTION>
+
+<SECTION>
 <FILE>element-legacyresample</FILE>
 <TITLE>legacyresample</TITLE>
 GstLegacyresample
diff --git a/gst/jpegparse/gstjpegparse.c b/gst/jpegparse/gstjpegparse.c
index 20823e2..1f4ecc7 100644
--- a/gst/jpegparse/gstjpegparse.c
+++ b/gst/jpegparse/gstjpegparse.c
@@ -3,6 +3,7 @@
  * jpegparse: a parser for JPEG streams
  *
  * Copyright (C) <2009> Arnout Vandecappelle (Essensium/Mind) <arnout@mind.be>
+ *                      Víctor Manuel Jáquez Leal <vjaquez@igalia.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,33 +20,85 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string.h>
-
-#include <gst/gst.h>
-
-#include "gstjpegparse.h"
-#include "gst/gst-i18n-plugin.h"
 
 /**
  * SECTION:element-jpegparse
+ * @short_description: JPEG parser
  *
- * Parses a JPEG stream into JPEG images.  It looks for EOI boundaries to split
- * a continuous stream into single-frame buffers.
- *
+ * Parses a JPEG stream into JPEG images.  It looks for EOI boundaries to
+ * split a continuous stream into single-frame buffers. Also reads the
+ * image header searching for image properties such as width and height
+ * among others.
  * <refsect2>
  * <title>Example launch line</title>
  * |[
  * gst-launch -v souphttpsrc location=... ! jpegparse ! matroskamux ! filesink location=...
  * ]|
- * The above pipeline fetches a motion JPEG stream from an IP camera over HTTP
- * and stores it in a matroska file.
+ * The above pipeline fetches a motion JPEG stream from an IP camera over
+ * HTTP and stores it in a matroska file.
  * </refsect2>
  */
 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gst/base/gstbytereader.h>
+
+#include "gstjpegparse.h"
+
+/*
+ * JPEG Markers
+ */
+#define SOF0      0xc0
+#define SOF1      0xc1
+#define SOF2      0xc2
+#define SOF3      0xc3
+
+#define SOF5      0xc5
+#define SOF6      0xc6
+#define SOF7      0xc7
+
+#define JPG       0xc8
+#define SOF9      0xc9
+#define SOF10     0xca
+#define SOF11     0xcb
+#define SOF13     0xcd
+#define SOF14     0xce
+#define SOF15     0xcf
+
+#define DHT       0xc4
+
+#define DAC       0xcc
+
+#define RST0      0xd0
+#define RST1      0xd1
+#define RST2      0xd2
+#define RST3      0xd3
+#define RST4      0xd4
+#define RST5      0xd5
+#define RST6      0xd6
+#define RST7      0xd7
+
+#define SOI       0xd8
+#define EOI       0xd9
+#define SOS       0xda
+#define DQT       0xdb
+#define DNL       0xdc
+#define DRI       0xdd
+#define DHP       0xde
+#define EXP       0xdf
+
+#define APP0      0xe0
+#define EXIF      0xe1
+#define APP15     0xef
+
+#define JPG0      0xf0
+#define JPG13     0xfd
+#define COM       0xfe
+
+#define TEM       0x01
+
 static const GstElementDetails gst_jpeg_parse_details =
 GST_ELEMENT_DETAILS ("JPEG stream parser",
     "Codec/Parser/Video",
@@ -56,36 +109,79 @@ static GstStaticPadTemplate gst_jpeg_parse_src_pad_template =
 GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("image/jpeg, parsed = true")
+    GST_STATIC_CAPS ("image/jpeg, "
+        "format = (fourcc) { I420, Y41B, UYVY, YV12 }, "
+        "width = (int) [ 0, MAX ],"
+        "height = (int) [ 0, MAX ], "
+        "interlaced = (boolean) { true, false }, "
+        "framerate = (fraction) [ 0/1, MAX ], " "parsed = (boolean) true")
     );
 
 static GstStaticPadTemplate gst_jpeg_parse_sink_pad_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("image/jpeg, parsed = false")
+    GST_STATIC_CAPS ("image/jpeg, parsed = (boolean) false")
     );
 
 GST_DEBUG_CATEGORY_STATIC (jpeg_parse_debug);
 #define GST_CAT_DEFAULT jpeg_parse_debug
 
-static GstElementClass *parent_class;   /* NULL */
+#define GST_JPEG_PARSE_GET_PRIVATE(obj)  \
+    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_JPEG_PARSE, GstJpegParsePrivate))
+
+struct _GstJpegParsePrivate
+{
+  GstPad *srcpad;
+
+  GstAdapter *adapter;
+
+  /* negotiated state */
+  gint caps_width, caps_height;
+  gint caps_framerate_numerator;
+  gint caps_framerate_denominator;
+
+  /* a new segment arrived */
+  gboolean new_segment;
+
+  /* the parsed frame size */
+  guint16 width, height;
+
+  /* TRUE if the image is interlaced */
+  gboolean interlaced;
+
+  /* fourcc color space */
+  guint32 fourcc;
+
+  /* TRUE if the src caps sets a specific framerate */
+  gboolean has_fps;
+
+  /* the (expected) timestamp of the next frame */
+  guint64 next_ts;
+
+  /* duration of the current frame */
+  guint64 duration;
+
+  /* video state */
+  gint framerate_numerator;
+  gint framerate_denominator;
+};
 
 static void gst_jpeg_parse_base_init (gpointer g_class);
 static void gst_jpeg_parse_class_init (GstJpegParseClass * klass);
 static void gst_jpeg_parse_dispose (GObject * object);
 
 static GstFlowReturn gst_jpeg_parse_chain (GstPad * pad, GstBuffer * buffer);
+static gboolean gst_jpeg_parse_sink_setcaps (GstPad * pad, GstCaps * caps);
 static gboolean gst_jpeg_parse_sink_event (GstPad * pad, GstEvent * event);
-static gboolean gst_jpeg_parse_src_event (GstPad * pad, GstEvent * event);
 static GstStateChangeReturn gst_jpeg_parse_change_state (GstElement * element,
     GstStateChange transition);
 
-#define DEBUG_INIT(bla) \
+#define _do_init(bla) \
   GST_DEBUG_CATEGORY_INIT (jpeg_parse_debug, "jpegparse", 0, "JPEG parser");
 
 GST_BOILERPLATE_FULL (GstJpegParse, gst_jpeg_parse, GstElement,
-    GST_TYPE_ELEMENT, DEBUG_INIT);
+    GST_TYPE_ELEMENT, _do_init);
 
 static void
 gst_jpeg_parse_base_init (gpointer g_class)
@@ -108,8 +204,7 @@ gst_jpeg_parse_class_init (GstJpegParseClass * klass)
   gstelement_class = (GstElementClass *) klass;
   gobject_class = (GObjectClass *) klass;
 
-  parent_class = g_type_class_peek_parent (klass);
-
+  g_type_class_add_private (gobject_class, sizeof (GstJpegParsePrivate));
   gobject_class->dispose = gst_jpeg_parse_dispose;
 
   gstelement_class->change_state =
@@ -117,47 +212,30 @@ gst_jpeg_parse_class_init (GstJpegParseClass * klass)
 }
 
 static void
-gst_jpeg_parse_reset (GstJpegParse * parse)
-{
-  if (parse->adapter) {
-    gst_adapter_clear (parse->adapter);
-    gst_object_unref (parse->adapter);
-    parse->adapter = NULL;
-  }
-  parse->srcpad = NULL;
-  parse->sinkpad = NULL;
-  parse->timestamp = GST_CLOCK_TIME_NONE;
-}
-
-static void
 gst_jpeg_parse_init (GstJpegParse * parse, GstJpegParseClass * g_class)
 {
-  gst_jpeg_parse_reset (parse);
+  GstPad *sinkpad;
+
+  parse->priv = GST_JPEG_PARSE_GET_PRIVATE (parse);
 
   /* create the sink and src pads */
-  parse->sinkpad =
-      gst_pad_new_from_static_template (&gst_jpeg_parse_sink_pad_template,
+  sinkpad = gst_pad_new_from_static_template (&gst_jpeg_parse_sink_pad_template,
       "sink");
-  gst_pad_set_chain_function (parse->sinkpad,
+  gst_pad_set_chain_function (sinkpad,
       GST_DEBUG_FUNCPTR (gst_jpeg_parse_chain));
-  gst_pad_set_event_function (parse->sinkpad,
+  gst_pad_set_event_function (sinkpad,
       GST_DEBUG_FUNCPTR (gst_jpeg_parse_sink_event));
-  gst_pad_set_caps (parse->sinkpad,
-      gst_static_pad_template_get_caps (&gst_jpeg_parse_sink_pad_template));
-  gst_pad_use_fixed_caps (parse->sinkpad);
-  gst_element_add_pad (GST_ELEMENT (parse), parse->sinkpad);
+  gst_pad_set_setcaps_function (sinkpad,
+      GST_DEBUG_FUNCPTR (gst_jpeg_parse_sink_setcaps));
+  gst_element_add_pad (GST_ELEMENT (parse), sinkpad);
 
-  parse->srcpad =
+  parse->priv->srcpad =
       gst_pad_new_from_static_template (&gst_jpeg_parse_src_pad_template,
       "src");
-  gst_pad_set_event_function (parse->srcpad,
-      GST_DEBUG_FUNCPTR (gst_jpeg_parse_src_event));
-  gst_pad_set_caps (parse->srcpad,
-      gst_static_pad_template_get_caps (&gst_jpeg_parse_src_pad_template));
-  gst_pad_use_fixed_caps (parse->srcpad);
-  gst_element_add_pad (GST_ELEMENT (parse), parse->srcpad);
-
-  parse->adapter = gst_adapter_new ();
+  gst_element_add_pad (GST_ELEMENT (parse), parse->priv->srcpad);
+
+  parse->priv->next_ts = GST_CLOCK_TIME_NONE;
+  parse->priv->adapter = gst_adapter_new ();
 }
 
 static void
@@ -165,28 +243,51 @@ gst_jpeg_parse_dispose (GObject * object)
 {
   GstJpegParse *parse = GST_JPEG_PARSE (object);
 
-  gst_jpeg_parse_reset (parse);
+  if (parse->priv->adapter != NULL) {
+    gst_adapter_clear (parse->priv->adapter);
+    gst_object_unref (parse->priv->adapter);
+    parse->priv->adapter = NULL;
+  }
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
+
+static gboolean
+gst_jpeg_parse_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstJpegParse *parse = GST_JPEG_PARSE (GST_OBJECT_PARENT (pad));
+  GstStructure *s = gst_caps_get_structure (caps, 0);
+  const GValue *framerate;
+
+  if ((framerate = gst_structure_get_value (s, "framerate")) != NULL) {
+    if (GST_VALUE_HOLDS_FRACTION (framerate)) {
+      parse->priv->framerate_numerator =
+          gst_value_get_fraction_numerator (framerate);
+      parse->priv->framerate_denominator =
+          gst_value_get_fraction_denominator (framerate);
+      parse->priv->has_fps = TRUE;
+      GST_DEBUG_OBJECT (parse, "got framerate of %d/%d",
+          parse->priv->framerate_numerator, parse->priv->framerate_denominator);
+    }
+  }
+
+  return TRUE;
+}
+
 /* Flush everything until the next JPEG header.  The header is considered
  * to be the a start marker (0xff 0xd8) followed by any other marker (0xff ...).
  * Returns TRUE if the header was found, FALSE if more data is needed. */
 static gboolean
 gst_jpeg_parse_skip_to_jpeg_header (GstJpegParse * parse)
 {
-  /* When this element was written,  gst_adapter_masked_scan_uint32() had just
-   * been added, so we still support the manual scanning method too. */
-#if GST_CHECK_VERSION(0,10,24) || \
-  (GST_CHECK_VERSION(0,10,23) && GST_VERSION_NANO >= 1)
   guint available, flush;
   gboolean ret = TRUE;
 
-  available = gst_adapter_available (parse->adapter);
+  available = gst_adapter_available (parse->priv->adapter);
   if (available < 4)
     return FALSE;
-  flush = gst_adapter_masked_scan_uint32 (parse->adapter, 0xffffff00,
+  flush = gst_adapter_masked_scan_uint32 (parse->priv->adapter, 0xffffff00,
       0xffd8ff00, 0, available);
   if (flush == -1) {
     flush = available - 3;      /* Last 3 bytes + 1 more may match header. */
@@ -194,40 +295,15 @@ gst_jpeg_parse_skip_to_jpeg_header (GstJpegParse * parse)
   }
   if (flush > 0) {
     GST_LOG_OBJECT (parse, "Skipping %u bytes.", flush);
-    gst_adapter_flush (parse->adapter, flush);
+    gst_adapter_flush (parse->priv->adapter, flush);
   }
   return ret;
-
-#else /* GST_CHECK_VERSION(0,10,24) */
-  guint size;
-
-  while ((size = gst_adapter_available (parse->adapter)) >= 3) {
-    const guint8 *data, *marker;
-    guint off;
-    data = gst_adapter_peek (parse->adapter, size);
-
-    if (data[0] == 0xff && data[1] == 0xd8 && data[2] == 0xff)
-      return TRUE;
-
-    marker = memchr (data + 1, 0xff, size - 1 - 2);
-    if (marker == NULL) {
-      off = size - 1;           /* keep last byte */
-    } else {
-      off = marker - data;
-    }
-
-    GST_LOG_OBJECT (parse, "Skipping %u bytes.", off);
-    gst_adapter_flush (parse->adapter, off);
-  }
-
-  return FALSE;
-#endif /* GST_CHECK_VERSION(0,10,24) */
 }
 
 static inline gboolean
 gst_jpeg_parse_parse_tag_has_entropy_segment (guint8 tag)
 {
-  if (tag == 0xda || (tag >= 0xd0 && tag <= 0xd7))
+  if (tag == SOS || (tag >= RST0 && tag <= RST7))
     return TRUE;
   return FALSE;
 }
@@ -245,7 +321,7 @@ gst_jpeg_parse_match_next_marker (const guint8 * data, guint size)
   g_return_val_if_fail (size >= 2, -1);
   tag = data[1];
 
-  if (tag >= 0xd0 && tag <= 0xd9)
+  if (tag >= RST0 && tag <= EOI)
     marker_len = 2;
   else if (G_UNLIKELY (size < 4))
     return -1;
@@ -289,7 +365,7 @@ gst_jpeg_parse_find_end_marker (GstJpegParse * parse, const guint8 * data,
         return -1;
     }
     /* Check for EOI */
-    if (G_UNLIKELY (tag == 0xd9)) {
+    if (G_UNLIKELY (tag == EOI)) {
       GST_DEBUG_OBJECT (parse, "EOI at %u", offset);
       return offset + 2;
     }
@@ -313,14 +389,14 @@ gst_jpeg_parse_get_image_length (GstJpegParse * parse)
   const guint8 *data;
   guint size, offset, start = 2;
 
-  size = gst_adapter_available (parse->adapter);
+  size = gst_adapter_available (parse->priv->adapter);
   if (size < 4) {
     GST_DEBUG_OBJECT (parse, "Insufficient data for end marker.");
     return 0;
   }
-  data = gst_adapter_peek (parse->adapter, size);
+  data = gst_adapter_peek (parse->priv->adapter, size);
 
-  g_return_val_if_fail (data[0] == 0xff && data[1] == 0xd8, 0);
+  g_return_val_if_fail (data[0] == 0xff && data[1] == SOI, 0);
 
   GST_DEBUG_OBJECT (parse, "Parsing jpeg image data (%u bytes)", size);
 
@@ -352,27 +428,253 @@ gst_jpeg_parse_get_image_length (GstJpegParse * parse)
   return start + offset;
 }
 
+static gboolean
+gst_jpeg_parse_sof (GstJpegParse * parse, GstByteReader * reader)
+{
+  guint8 numcomps;              /* Number of components in image
+                                   (1 for gray, 3 for YUV, etc.) */
+  guint8 precision;             /* precision (in bits) for the samples */
+  guint8 compId[3];             /* unique value identifying each component */
+  guint8 qtId[3];               /* quantization table ID to use for this comp */
+  guint8 blockWidth[3];         /* Array[numComponents] giving the number of
+                                   blocks (horiz) in this component */
+  guint8 blockHeight[3];        /* Same for the vertical part of this component */
+  guint8 i, value;
+  gint temp;
+
+  if (!gst_byte_reader_skip (reader, 2))
+    return FALSE;
+
+  /* Get sample precision */
+  if (!gst_byte_reader_get_uint8 (reader, &precision))
+    return FALSE;
+
+  /* Get w and h */
+  if (!gst_byte_reader_get_uint16_be (reader, &parse->priv->height))
+    return FALSE;
+  if (!gst_byte_reader_get_uint16_be (reader, &parse->priv->width))
+    return FALSE;
+
+  /* Get number of components */
+  if (!gst_byte_reader_get_uint8 (reader, &numcomps))
+    return FALSE;
+
+  if (numcomps > 3)
+    return FALSE;
+
+  /* Get decimation and quantization table id for each component */
+  for (i = 0; i < numcomps; i++) {
+    /* Get component ID number */
+    if (!gst_byte_reader_get_uint8 (reader, &value))
+      return FALSE;
+    compId[i] = value;
+
+    /* Get decimation */
+    if (!gst_byte_reader_get_uint8 (reader, &value))
+      return FALSE;
+    blockWidth[i] = (value & 0xf0) >> 4;
+    blockHeight[i] = (value & 0x0f);
+
+    /* Get quantization table id */
+    if (!gst_byte_reader_get_uint8 (reader, &value))
+      return FALSE;
+    qtId[i] = value;
+  }
+
+  if (numcomps == 1) {
+    /* gray image - no fourcc */
+    parse->priv->fourcc = 0;
+  } else if (numcomps == 3) {
+    temp = (blockWidth[0] * blockHeight[0]) / (blockWidth[1] * blockHeight[1]);
+
+    if (temp == 4 && blockHeight[0] == 2)
+      parse->priv->fourcc = GST_MAKE_FOURCC ('I', '4', '2', '0');
+    else if (temp == 4 && blockHeight[0] == 4)
+      parse->priv->fourcc = GST_MAKE_FOURCC ('Y', '4', '1', 'B');
+    else if (temp == 2)
+      parse->priv->fourcc = GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y');
+    else if (temp == 1)
+      parse->priv->fourcc = GST_MAKE_FOURCC ('Y', 'V', '1', '2');
+    else
+      parse->priv->fourcc = 0;
+  } else {
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_jpeg_parse_read_header (GstJpegParse * parse, GstBuffer * buffer)
+{
+  GstByteReader reader = GST_BYTE_READER_INIT_FROM_BUFFER (buffer);
+  guint8 marker;
+  guint16 comsize;
+  gboolean foundSOF = FALSE;
+
+  if (!gst_byte_reader_peek_uint8 (&reader, &marker))
+    goto error;
+
+  while (marker == 0xff) {
+    if (!gst_byte_reader_skip (&reader, 1))
+      goto error;
+
+    if (!gst_byte_reader_get_uint8 (&reader, &marker))
+      goto error;
+
+    GST_INFO_OBJECT (parse, "marker = %x", marker);
+
+    switch (marker) {
+      case SOS:                /* start of scan (begins compressed data) */
+        return foundSOF;
+
+      case SOI:
+        break;
+
+      case DRI:
+        if (!gst_byte_reader_skip (&reader, 4)) /* fixed size */
+          goto error;
+        break;
+
+      case APP0:
+      case EXIF:
+      case APP15:
+      case COM:
+      case DHT:
+      case DQT:
+        /* Ignore these codes */
+        if (!gst_byte_reader_get_uint16_be (&reader, &comsize))
+          goto error;
+        if (!gst_byte_reader_skip (&reader, comsize - 2))
+          goto error;
+        GST_LOG_OBJECT (parse, "comment skiping %u bytes", comsize - 2);
+        break;
+
+      case SOF2:
+        parse->priv->interlaced = TRUE;
+
+      case SOF0:
+        /* Flush length field */
+        foundSOF = TRUE;
+        if (!gst_jpeg_parse_sof (parse, &reader))
+          goto error;
+
+        return TRUE;
+
+      default:
+        /* Not SOF or SOI.  Must not be a JPEG file (or file pointer
+         * is placed wrong).  In either case, it's an error. */
+        return FALSE;
+    }
+
+    if (!gst_byte_reader_peek_uint8 (&reader, &marker))
+      goto error;
+  }
+
+  return foundSOF;
+
+error:
+  GST_WARNING_OBJECT (parse, "Error parsing image header");
+  return FALSE;
+}
+
+static gboolean
+gst_jpeg_parse_set_new_caps (GstJpegParse * parse, gboolean header_ok)
+{
+  GstCaps *caps;
+  gboolean res;
+
+  caps = gst_caps_new_simple ("image/jpeg",
+      "parsed", G_TYPE_BOOLEAN, TRUE, NULL);
+
+  if (header_ok == TRUE) {
+    gst_caps_set_simple (caps,
+        "format", GST_TYPE_FOURCC, parse->priv->fourcc,
+        "interlaced", G_TYPE_BOOLEAN, parse->priv->interlaced,
+        "width", G_TYPE_INT, parse->priv->width,
+        "height", G_TYPE_INT, parse->priv->height, NULL);
+  }
+
+  if (parse->priv->has_fps == TRUE) {
+    /* we have a framerate */
+    gst_caps_set_simple (caps, "framerate", GST_TYPE_FRACTION,
+        parse->priv->framerate_numerator,
+        parse->priv->framerate_denominator, NULL);
+
+    if (!GST_CLOCK_TIME_IS_VALID (parse->priv->duration)
+        && parse->priv->framerate_numerator != 0) {
+      parse->priv->duration = gst_util_uint64_scale_int (GST_SECOND,
+          parse->priv->framerate_numerator, parse->priv->framerate_denominator);
+    }
+  } else {
+    /* unknown duration */
+    parse->priv->duration = GST_CLOCK_TIME_NONE;
+  }
+
+  GST_DEBUG_OBJECT (parse, "setting downstream caps to %" GST_PTR_FORMAT, caps);
+  res = gst_pad_set_caps (parse->priv->srcpad, caps);
+  gst_caps_unref (caps);
+
+  return res;
+
+}
+
 static GstFlowReturn
 gst_jpeg_parse_push_buffer (GstJpegParse * parse, guint len)
 {
   GstBuffer *outbuf;
   GstFlowReturn ret = GST_FLOW_OK;
+  gboolean header_ok;
 
-  outbuf = gst_adapter_take_buffer (parse->adapter, len);
+  outbuf = gst_adapter_take_buffer (parse->priv->adapter, len);
   if (outbuf == NULL) {
-    GST_ERROR_OBJECT (parse, "Failed to take buffer of size %u", len);
+    GST_ELEMENT_ERROR (parse, STREAM, DECODE,
+        ("Failed to take buffer of size %u", len),
+        ("Failed to take buffer of size %u", len));
     return GST_FLOW_ERROR;
   }
-  GST_BUFFER_TIMESTAMP (outbuf) = parse->timestamp;
-  gst_buffer_set_caps (outbuf, GST_PAD_CAPS (parse->srcpad));
-  parse->timestamp = GST_CLOCK_TIME_NONE;
 
-  /* FIXME set duration? */
+  header_ok = gst_jpeg_parse_read_header (parse, outbuf);
+
+  if (parse->priv->new_segment == TRUE
+      || parse->priv->width != parse->priv->caps_width
+      || parse->priv->height != parse->priv->caps_height
+      || parse->priv->framerate_numerator !=
+      parse->priv->caps_framerate_numerator
+      || parse->priv->framerate_denominator !=
+      parse->priv->caps_framerate_denominator) {
+    if (!gst_jpeg_parse_set_new_caps (parse, header_ok)) {
+      GST_ELEMENT_ERROR (parse, CORE, NEGOTIATION,
+          ("Can't set caps to the src pad"), ("Can't set caps to the src pad"));
+      return GST_FLOW_ERROR;
+    }
+
+    parse->priv->new_segment = FALSE;
+    parse->priv->caps_width = parse->priv->width;
+    parse->priv->caps_height = parse->priv->height;
+    parse->priv->caps_framerate_numerator = parse->priv->framerate_numerator;
+    parse->priv->caps_framerate_denominator =
+        parse->priv->framerate_denominator;
+  }
+
+  GST_BUFFER_TIMESTAMP (outbuf) = parse->priv->next_ts;
+
+  if (parse->priv->has_fps && GST_CLOCK_TIME_IS_VALID (parse->priv->next_ts)
+      && GST_CLOCK_TIME_IS_VALID (parse->priv->duration)) {
+    parse->priv->next_ts += parse->priv->duration;
+  } else {
+    parse->priv->duration = GST_CLOCK_TIME_NONE;
+    parse->priv->next_ts = GST_CLOCK_TIME_NONE;
+  }
+
+  GST_BUFFER_DURATION (outbuf) = parse->priv->duration;
+
+  gst_buffer_set_caps (outbuf, GST_PAD_CAPS (parse->priv->srcpad));
 
   GST_LOG_OBJECT (parse, "pushing buffer (ts=%" GST_TIME_FORMAT ", len=%u)",
       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (outbuf)), len);
 
-  ret = gst_pad_push (parse->srcpad, outbuf);
+  ret = gst_pad_push (parse->priv->srcpad, outbuf);
 
   return ret;
 }
@@ -382,18 +684,21 @@ gst_jpeg_parse_chain (GstPad * pad, GstBuffer * buf)
 {
   GstJpegParse *parse;
   guint len;
-  GstClockTime timestamp;
+  GstClockTime timestamp, duration;
   GstFlowReturn ret = GST_FLOW_OK;
 
   parse = GST_JPEG_PARSE (GST_PAD_PARENT (pad));
 
   timestamp = GST_BUFFER_TIMESTAMP (buf);
+  duration = GST_BUFFER_DURATION (buf);
 
-  gst_adapter_push (parse->adapter, buf);
+  gst_adapter_push (parse->priv->adapter, buf);
 
   while (ret == GST_FLOW_OK && gst_jpeg_parse_skip_to_jpeg_header (parse)) {
-    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (parse->timestamp)))
-      parse->timestamp = timestamp;
+    if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (parse->priv->next_ts)))
+      parse->priv->next_ts = timestamp;
+
+    parse->priv->duration = duration;
 
     len = gst_jpeg_parse_get_image_length (parse);
     if (len == 0)
@@ -402,15 +707,15 @@ gst_jpeg_parse_chain (GstPad * pad, GstBuffer * buf)
     ret = gst_jpeg_parse_push_buffer (parse, len);
   }
 
-  GST_DEBUG_OBJECT (parse, "No start marker found, waiting for more data.");
+  GST_DEBUG_OBJECT (parse, "No further start marker found.");
   return ret;
 }
 
 static gboolean
-gst_jpeg_parse_src_event (GstPad * pad, GstEvent * event)
+gst_jpeg_parse_sink_event (GstPad * pad, GstEvent * event)
 {
   GstJpegParse *parse;
-  gboolean res;
+  gboolean res = TRUE;
 
   parse = GST_JPEG_PARSE (gst_pad_get_parent (pad));
 
@@ -419,39 +724,28 @@ gst_jpeg_parse_src_event (GstPad * pad, GstEvent * event)
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_EOS:{
       /* Push the remaining data, even though it's incomplete */
-      guint available = gst_adapter_available (parse->adapter);
-
+      guint available = gst_adapter_available (parse->priv->adapter);
       if (available > 0)
         gst_jpeg_parse_push_buffer (parse, available);
+      gst_pad_push_event (parse->priv->srcpad, event);
       break;
     }
     case GST_EVENT_NEWSEGMENT:
       /* Discard any data in the adapter.  There should have been an EOS before
        * to flush it. */
-      gst_adapter_clear (parse->adapter);
-      parse->timestamp = GST_CLOCK_TIME_NONE;
+      gst_adapter_clear (parse->priv->adapter);
+      gst_pad_push_event (parse->priv->srcpad, event);
+      parse->priv->new_segment = TRUE;
       break;
     default:
+      res = gst_pad_event_default (pad, event);
       break;
   }
 
-  res = gst_pad_push_event (parse->sinkpad, event);
-
   gst_object_unref (parse);
   return res;
 }
 
-static gboolean
-gst_jpeg_parse_sink_event (GstPad * pad, GstEvent * event)
-{
-  gboolean ret = TRUE;
-  GstJpegParse *parse = GST_JPEG_PARSE (GST_OBJECT_PARENT (pad));
-
-  ret = gst_pad_push_event (parse->srcpad, event);
-
-  return ret;
-}
-
 static GstStateChangeReturn
 gst_jpeg_parse_change_state (GstElement * element, GstStateChange transition)
 {
@@ -460,14 +754,33 @@ gst_jpeg_parse_change_state (GstElement * element, GstStateChange transition)
 
   parse = GST_JPEG_PARSE (element);
 
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      parse->priv->has_fps = FALSE;
+
+      parse->priv->interlaced = FALSE;
+      parse->priv->width = parse->priv->height = 0;
+      parse->priv->framerate_numerator = 0;
+      parse->priv->framerate_denominator = 1;
+
+      parse->priv->caps_framerate_numerator =
+          parse->priv->caps_framerate_denominator = 0;
+      parse->priv->caps_width = parse->priv->caps_height = -1;
+
+      parse->priv->new_segment = FALSE;
+
+      parse->priv->next_ts = GST_CLOCK_TIME_NONE;
+    default:
+      break;
+  }
+
   ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
   if (ret != GST_STATE_CHANGE_SUCCESS)
     return ret;
 
   switch (transition) {
     case GST_STATE_CHANGE_PAUSED_TO_READY:
-      gst_adapter_clear (parse->adapter);
-      parse->timestamp = GST_CLOCK_TIME_NONE;
+      gst_adapter_clear (parse->priv->adapter);
       break;
     default:
       break;
@@ -489,6 +802,6 @@ plugin_init (GstPlugin * plugin)
 
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
-    "jpeg",
+    "jpegparse",
     "JPEG parser",
     plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/jpegparse/gstjpegparse.h b/gst/jpegparse/gstjpegparse.h
index 5d6ce1d..3d8c45e 100644
--- a/gst/jpegparse/gstjpegparse.h
+++ b/gst/jpegparse/gstjpegparse.h
@@ -40,25 +40,20 @@ G_BEGIN_DECLS
   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JPEG_PARSE))
 
 typedef struct _GstJpegParse           GstJpegParse;
+typedef struct _GstJpegParsePrivate    GstJpegParsePrivate;
 typedef struct _GstJpegParseClass      GstJpegParseClass;
 
 struct _GstJpegParse {
   GstElement element;
-
-  /* pads */
-  GstPad      *sinkpad;
-  GstPad      *srcpad;
-
-  GstAdapter  *adapter;
-  GstClockTime timestamp;
+  GstJpegParsePrivate *priv;
 };
 
 struct _GstJpegParseClass {
   GstElementClass  parent_class;
 };
 
-GType gst_jpeg_parse_get_type(void);
+GType gst_jpeg_parse_get_type (void);
 
 G_END_DECLS
 
-#endif
+#endif /* __GST_JPEG_PARSE_H__ */
-- 
1.6.3.1

