From ab9bfea0a8ac7c240eae49ce013f365f5538490f Mon Sep 17 00:00:00 2001
From: =?utf-8?q?Daniel=20D=C3=ADaz?= <yosoy@danieldiaz.org>
Date: Thu, 17 Dec 2009 17:24:37 -0600
Subject: [PATCH] freeze: Add timeout property.
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

The timeout property allows freeze to end after a timeout occurs.

Signed-off-by: Daniel DÃ­az <yosoy@danieldiaz.org>
---
 gst/freeze/gstfreeze.c |   42 +++++++++++++++++++++++++++++++++++++++++-
 gst/freeze/gstfreeze.h |    1 +
 2 files changed, 42 insertions(+), 1 deletions(-)

diff --git a/gst/freeze/gstfreeze.c b/gst/freeze/gstfreeze.c
index d554988..01e05b0 100644
--- a/gst/freeze/gstfreeze.c
+++ b/gst/freeze/gstfreeze.c
@@ -44,6 +44,7 @@ enum
 {
   ARG_0,
   ARG_MAX_BUFFERS,
+  ARG_TIMEOUT,
 };
 
 
@@ -52,7 +53,8 @@ GST_ELEMENT_DETAILS ("Stream freezer",
     "Generic",
     "Makes a stream from buffers of data",
     "Gergely Nagy <gergely.nagy@neteyes.hu>,"
-    " Renato Filho <renato.filho@indt.org.br>");
+    "Renato Filho <renato.filho@indt.org.br>,"
+    "Daniel Diaz <yosoy@danieldiaz.org>");
 
 static GstStaticPadTemplate gst_freeze_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -83,6 +85,8 @@ static gboolean gst_freeze_sink_activate_pull (GstPad * sinkpad,
 static gboolean gst_freeze_sink_event (GstPad * pad, GstEvent * event);
 static void gst_freeze_clear_buffer (GstFreeze * freeze);
 static void gst_freeze_buffer_free (gpointer data, gpointer user_data);
+static void gst_freeze_set_timeout (gpointer data);
+static gboolean gst_freeze_finish_stream (gpointer data);
 
 
 GST_BOILERPLATE (GstFreeze, gst_freeze, GstElement, GST_TYPE_ELEMENT);
@@ -117,6 +121,12 @@ gst_freeze_class_init (GstFreezeClass * klass)
           "max-buffers",
           "Maximum number of buffers", 0, G_MAXUINT, 1, G_PARAM_READWRITE));
 
+  g_object_class_install_property (object_class,
+      ARG_TIMEOUT,
+      g_param_spec_int ("timeout",
+          "timeout",
+          "Timeout before closing stream", 0, G_MAXINT, 1, G_PARAM_READWRITE));
+
   object_class->dispose = gst_freeze_dispose;
 
 }
@@ -169,6 +179,9 @@ gst_freeze_set_property (GObject * object, guint prop_id,
     case ARG_MAX_BUFFERS:
       freeze->max_buffers = g_value_get_uint (value);
       break;
+    case ARG_TIMEOUT:
+      freeze->timeout = g_value_get_int (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -185,6 +198,9 @@ gst_freeze_get_property (GObject * object, guint prop_id,
     case ARG_MAX_BUFFERS:
       g_value_set_uint (value, freeze->max_buffers);
       break;
+    case ARG_TIMEOUT:
+      g_value_set_int (value, freeze->timeout);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -210,6 +226,7 @@ gst_freeze_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_NULL_TO_READY:
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
       freeze->timestamp_offset = freeze->running_time = 0;
+      gst_freeze_set_timeout (freeze);
       break;
     default:
       break;
@@ -379,6 +396,29 @@ gst_freeze_sink_event (GstPad * pad, GstEvent * event)
 }
 
 static gboolean
+gst_freeze_finish_stream (gpointer data)
+{
+  GstFreeze *freeze = GST_FREEZE (data);
+  GstState cur_state;
+
+  gst_element_get_state (GST_ELEMENT (freeze), &cur_state, NULL, 0);
+  if (cur_state != GST_STATE_PLAYING)
+    return TRUE;
+
+  gst_pad_push_event (freeze->srcpad, gst_event_new_eos ());
+  return FALSE;
+}
+
+static void
+gst_freeze_set_timeout (gpointer data)
+{
+  GstFreeze *freeze = GST_FREEZE (data);
+
+  if (freeze->timeout > 0)
+    g_timeout_add (freeze->timeout * 1000, gst_freeze_finish_stream, freeze);
+}
+
+static gboolean
 plugin_init (GstPlugin * plugin)
 {
   GST_DEBUG_CATEGORY_INIT (freeze_debug, "freeze", 0, "Stream freezer");
diff --git a/gst/freeze/gstfreeze.h b/gst/freeze/gstfreeze.h
index 47cead7..1d8715b 100644
--- a/gst/freeze/gstfreeze.h
+++ b/gst/freeze/gstfreeze.h
@@ -43,6 +43,7 @@ struct _GstFreeze
   GstBuffer *current;
   
   guint max_buffers;
+  gint timeout;
 
   gint64 timestamp_offset;
   gint64 offset;
-- 
1.6.3.1

