From 993b705fd4919be76a28474bbb4813d365d7cd54 Mon Sep 17 00:00:00 2001
From: Rob Clark <rob@ti.com>
Date: Thu, 30 Jul 2009 14:50:05 -0500
Subject: [PATCH] This is a combination of 16 commits.

The 16 commits are:
* add rowstride support to video utility functions
* stridetransform: skeletal implementation of stridetransform element
* stridetransform: implement caps negotiation and related parts
* stridetransform: implement transform function
* audioconvert: add NEON acceleration for some conversions
* add gst_stride_transform_transform_size()
* fix a small typo..  need to use the smaller of {new_width, orig_width} for the line-by-line copy to avoid overwriting past end of buffer
* Add NV12 support in stridetransform
* add basic support for I420->NV12 colorspace conversion
* fix to avoid parsing caps on every frame
* refactor stridetransform to make it easier to add new transforms (stride and/or colorspace)
* add some neon
* add support to convert to YUY2/YUYV color format
* Add support for RGB565 formats to gstvideo
* Add support for RGB565 to stridetransform
* stridetransform:  fix problem transforming caps with list of fourcc's

They all come from http://gitorious.org/robclark-gstreamer/gst-plugins-base/commits/master

Signed-off-by: Daniel Diaz <ddiaz@ti.com>
---
 configure.ac                        |    3 +
 gst-libs/gst/video/gstvideofilter.c |    8 +-
 gst-libs/gst/video/video.c          |  289 ++++++++++++++++++++----
 gst-libs/gst/video/video.h          |   55 ++++-
 gst/audioconvert/Makefile.am        |    1 +
 gst/audioconvert/armv7.c            |  209 +++++++++++++++++
 gst/audioconvert/audioconvert.c     |   20 +-
 gst/audioconvert/gstaudioquantize.c |    4 +-
 gst/audioconvert/gstchannelmix.c    |    4 +-
 gst/stride/Makefile.am              |   17 ++
 gst/stride/armv7.s                  |  182 +++++++++++++++
 gst/stride/convert.c                |  371 ++++++++++++++++++++++++++++++
 gst/stride/gststridetransform.c     |  426 +++++++++++++++++++++++++++++++++++
 gst/stride/gststridetransform.h     |   92 ++++++++
 gst/stride/plugin.c                 |   45 ++++
 15 files changed, 1656 insertions(+), 70 deletions(-)
 create mode 100644 gst/audioconvert/armv7.c
 create mode 100644 gst/stride/Makefile.am
 create mode 100644 gst/stride/armv7.s
 create mode 100644 gst/stride/convert.c
 create mode 100644 gst/stride/gststridetransform.c
 create mode 100644 gst/stride/gststridetransform.h
 create mode 100644 gst/stride/plugin.c

diff --git a/configure.ac b/configure.ac
index e461d86..25912fc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -53,6 +53,7 @@ dnl AS_LIBTOOL_TAGS
 
 AC_LIBTOOL_WIN32_DLL
 AM_PROG_LIBTOOL
+AM_PROG_AS
 
 dnl *** required versions of GStreamer stuff ***
 GST_REQ=0.10.25.1
@@ -325,6 +326,7 @@ AG_GST_CHECK_PLUGIN(ffmpegcolorspace)
 AG_GST_CHECK_PLUGIN(gdp)
 AG_GST_CHECK_PLUGIN(playback)
 AG_GST_CHECK_PLUGIN(audioresample)
+AG_GST_CHECK_PLUGIN(stride)
 AG_GST_CHECK_PLUGIN(subparse)
 AG_GST_CHECK_PLUGIN(tcp)
 AG_GST_CHECK_PLUGIN(typefind)
@@ -791,6 +793,7 @@ gst/ffmpegcolorspace/Makefile
 gst/gdp/Makefile
 gst/playback/Makefile
 gst/audioresample/Makefile
+gst/stride/Makefile
 gst/subparse/Makefile
 gst/tcp/Makefile
 gst/typefind/Makefile
diff --git a/gst-libs/gst/video/gstvideofilter.c b/gst-libs/gst/video/gstvideofilter.c
index 2d08a60..6b2d7b7 100644
--- a/gst-libs/gst/video/gstvideofilter.c
+++ b/gst-libs/gst/video/gstvideofilter.c
@@ -21,7 +21,7 @@
  /**
  * SECTION:gstvideofilter
  * @short_description: Base class for video filters
- * 
+ *
  * <refsect2>
  * <para>
  * Provides useful functions and a base class for video filters.
@@ -78,14 +78,14 @@ gst_video_filter_get_unit_size (GstBaseTransform * btrans, GstCaps * caps,
     guint * size)
 {
   GstVideoFormat fmt;
-  gint width, height;
+  gint width, height, rowstride;
 
-  if (!gst_video_format_parse_caps (caps, &fmt, &width, &height)) {
+  if (!gst_video_format_parse_caps_strided (caps, &fmt, &width, &height, &rowstride)) {
     GST_WARNING_OBJECT (btrans, "Failed to parse caps %" GST_PTR_FORMAT, caps);
     return FALSE;
   }
 
-  *size = gst_video_format_get_size (fmt, width, height);
+  *size = gst_video_format_get_size_strided (fmt, width, height, rowstride);
 
   GST_DEBUG_OBJECT (btrans, "Returning size %u bytes for caps %"
       GST_PTR_FORMAT, *size, caps);
diff --git a/gst-libs/gst/video/video.c b/gst-libs/gst/video/video.c
index 84e32a1..8d4b3f7 100644
--- a/gst-libs/gst/video/video.c
+++ b/gst-libs/gst/video/video.c
@@ -31,7 +31,7 @@
  *
  * <refsect2>
  * <para>
- * This library contains some helper functions and includes the 
+ * This library contains some helper functions and includes the
  * videosink and videofilter base classes.
  * </para>
  * </refsect2>
@@ -43,6 +43,8 @@ static GstVideoFormat gst_video_format_from_rgba32_masks (int red_mask,
     int green_mask, int blue_mask, int alpha_mask);
 static GstVideoFormat gst_video_format_from_rgb24_masks (int red_mask,
     int green_mask, int blue_mask);
+static GstVideoFormat gst_video_format_from_rgb16_masks (int red_mask,
+    int green_mask, int blue_mask);
 
 
 /**
@@ -51,7 +53,7 @@ static GstVideoFormat gst_video_format_from_rgb24_masks (int red_mask,
  *
  * A convenience function to retrieve a GValue holding the framerate
  * from the caps on a pad.
- * 
+ *
  * The pad needs to have negotiated caps containing a framerate property.
  *
  * Returns: NULL if the pad has no configured caps or the configured caps
@@ -104,7 +106,7 @@ gst_video_frame_rate (GstPad * pad)
  *
  * Inspect the caps of the provided pad and retrieve the width and height of
  * the video frames it is configured for.
- * 
+ *
  * The pad needs to have negotiated caps containing width and height properties.
  *
  * Returns: TRUE if the width and height could be retrieved.
@@ -156,13 +158,13 @@ gst_video_get_size (GstPad * pad, gint * width, gint * height)
  * @display_par_n: Numerator of the pixel aspect ratio of the display device
  * @display_par_d: Denominator of the pixel aspect ratio of the display device
  *
- * Given the Pixel Aspect Ratio and size of an input video frame, and the 
- * pixel aspect ratio of the intended display device, calculates the actual 
+ * Given the Pixel Aspect Ratio and size of an input video frame, and the
+ * pixel aspect ratio of the intended display device, calculates the actual
  * display ratio the video will be rendered with.
  *
- * Returns: A boolean indicating success and a calculated Display Ratio in the 
- * dar_n and dar_d parameters. 
- * The return value is FALSE in the case of integer overflow or other error. 
+ * Returns: A boolean indicating success and a calculated Display Ratio in the
+ * dar_n and dar_d parameters.
+ * The return value is FALSE in the case of integer overflow or other error.
  *
  * Since: 0.10.7
  */
@@ -250,28 +252,15 @@ gst_video_format_parse_caps_interlaced (GstCaps * caps, gboolean * interlaced)
 }
 
 /**
- * gst_video_format_parse_caps:
- * @caps: the #GstCaps to parse
- * @format: the #GstVideoFormat of the video represented by @caps (output)
- * @width: the width of the video represented by @caps, may be NULL (output)
- * @height: the height of the video represented by @caps, may be NULL (output)
- *
- * Determines the #GstVideoFormat of @caps and places it in the location
- * pointed to by @format.  Extracts the size of the video and places it
- * in the location pointed to by @width and @height.  If @caps does not
- * represent one of the raw video formats listed in #GstVideoFormat, the
- * function will fail and return FALSE.
- *
- * Since: 0.10.16
- *
- * Returns: TRUE if @caps was parsed correctly.
+ * see gst_video_format_parse_caps_strided and gst_video_format_parse_caps
  */
-gboolean
-gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
-    int *width, int *height)
+static gboolean
+parse_caps (GstCaps * caps, GstVideoFormat * format, gint *width, gint *height,
+    gboolean stride_ok, gint *rowstride)
 {
   GstStructure *structure;
   gboolean ok = TRUE;
+  gboolean strided = FALSE;
 
   if (!gst_caps_is_fixed (caps))
     return FALSE;
@@ -279,7 +268,10 @@ gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
   structure = gst_caps_get_structure (caps, 0);
 
   if (format) {
-    if (gst_structure_has_name (structure, "video/x-raw-yuv")) {
+    if (gst_structure_has_name (structure, "video/x-raw-yuv") ||
+        (stride_ok &&
+            gst_structure_has_name (structure, "video/x-raw-yuv-strided") &&
+            (strided=TRUE) /* single '=' intentional */)) {
       guint32 fourcc;
 
       ok &= gst_structure_get_fourcc (structure, "format", &fourcc);
@@ -288,7 +280,10 @@ gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
       if (*format == GST_VIDEO_FORMAT_UNKNOWN) {
         ok = FALSE;
       }
-    } else if (gst_structure_has_name (structure, "video/x-raw-rgb")) {
+    } else if (gst_structure_has_name (structure, "video/x-raw-rgb") ||
+        (stride_ok &&
+            gst_structure_has_name (structure, "video/x-raw-rgb-strided") &&
+            (strided=TRUE) /* single '=' intentional */)) {
       int depth;
       int bpp;
       int endianness;
@@ -325,14 +320,22 @@ gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
         if (*format == GST_VIDEO_FORMAT_UNKNOWN) {
           ok = FALSE;
         }
-      } else {
-        ok = FALSE;
+      } else if (depth == 16 && bpp == 16 && endianness == G_BIG_ENDIAN){
+          *format = gst_video_format_from_rgb16_masks (red_mask, green_mask,
+                  blue_mask);
+          if (*format == GST_VIDEO_FORMAT_UNKNOWN) {
+              ok = FALSE;
+          }
       }
     } else {
       ok = FALSE;
     }
   }
 
+  /* note: should we require that the caps have these fields, even if
+   * the caller does not particularly request them??
+   */
+
   if (width) {
     ok &= gst_structure_get_int (structure, "width", width);
   }
@@ -341,11 +344,70 @@ gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
     ok &= gst_structure_get_int (structure, "height", height);
   }
 
+  if (rowstride) {
+    if (strided) {
+      ok &= gst_structure_get_int (structure, "rowstride", rowstride);
+    } else {
+      *rowstride = 0;  /* not a strided format */
+    }
+  }
+
   return ok;
 }
 
 
 /**
+ * gst_video_format_parse_caps_strided:
+ * @caps: the #GstCaps to parse
+ * @format: the #GstVideoFormat of the video represented by @caps (output)
+ * @width: the width of the video represented by @caps, may be NULL (output)
+ * @height: the height of the video represented by @caps, may be NULL (output)
+ * @rowstride: the rowstride (in bytes) represented by @caps, or 0 if there
+ *    is no rowstride, may be NULL (output)
+ *
+ * Determines the #GstVideoFormat of @caps and places it in the location
+ * pointed to by @format.  Extracts the size of the video and places it
+ * in the location pointed to by @width and @height.  Extracts the row-
+ * stride and places it in the location pointed to by @rowstride.  If
+ * @caps does not represent one of the raw video formats listed in
+ * #GstVideoFormat, the function will fail and return FALSE.
+ *
+ * Since: ???
+ *
+ * Returns: TRUE if @caps was parsed correctly.
+ */
+gboolean
+gst_video_format_parse_caps_strided (GstCaps * caps, GstVideoFormat * format,
+    int *width, int *height, int *rowstride)
+{
+  return parse_caps (caps, format, width, height, TRUE, rowstride);
+}
+
+/**
+ * gst_video_format_parse_caps:
+ * @caps: the #GstCaps to parse
+ * @format: the #GstVideoFormat of the video represented by @caps (output)
+ * @width: the width of the video represented by @caps, may be NULL (output)
+ * @height: the height of the video represented by @caps, may be NULL (output)
+ *
+ * Determines the #GstVideoFormat of @caps and places it in the location
+ * pointed to by @format.  Extracts the size of the video and places it
+ * in the location pointed to by @width and @height.  If @caps does not
+ * represent one of the raw video formats listed in #GstVideoFormat, the
+ * function will fail and return FALSE.
+ *
+ * Since: 0.10.16
+ *
+ * Returns: TRUE if @caps was parsed correctly.
+ */
+gboolean
+gst_video_format_parse_caps (GstCaps * caps, GstVideoFormat * format,
+    int *width, int *height)
+{
+  return parse_caps (caps, format, width, height, FALSE, NULL);
+}
+
+/**
  * gst_video_parse_caps_framerate:
  * @caps: pointer to a #GstCaps instance
  * @fps_n: pointer to integer to hold numerator of frame rate (output)
@@ -444,10 +506,11 @@ gst_video_format_new_caps_interlaced (GstVideoFormat format, int width,
 }
 
 /**
- * gst_video_format_new_caps:
+ * gst_video_format_new_caps_strided:
  * @format: the #GstVideoFormat describing the raw video format
  * @width: width of video
  * @height: height of video
+ * @rowstride: the rowstride (in bytes), or 0 if no rowstride
  * @framerate_n: numerator of frame rate
  * @framerate_d: denominator of frame rate
  * @par_n: numerator of pixel aspect ratio
@@ -455,26 +518,29 @@ gst_video_format_new_caps_interlaced (GstVideoFormat format, int width,
  *
  * Creates a new #GstCaps object based on the parameters provided.
  *
- * Since: 0.10.16
+ * Since: ???
  *
  * Returns: a new #GstCaps object, or NULL if there was an error
  */
 GstCaps *
-gst_video_format_new_caps (GstVideoFormat format, int width, int height,
+gst_video_format_new_caps_strided (GstVideoFormat format,
+    int width, int height, int rowstride,
     int framerate_n, int framerate_d, int par_n, int par_d)
 {
+  GstCaps *caps = NULL;
+
   g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, NULL);
   g_return_val_if_fail (width > 0 && height > 0, NULL);
 
   if (gst_video_format_is_yuv (format)) {
-    return gst_caps_new_simple ("video/x-raw-yuv",
+    caps = gst_caps_new_simple (
+        rowstride ? "video/x-raw-yuv-strided" : "video/x-raw-yuv",
         "format", GST_TYPE_FOURCC, gst_video_format_to_fourcc (format),
         "width", G_TYPE_INT, width,
         "height", G_TYPE_INT, height,
         "framerate", GST_TYPE_FRACTION, framerate_n, framerate_d,
         "pixel-aspect-ratio", GST_TYPE_FRACTION, par_n, par_d, NULL);
-  }
-  if (gst_video_format_is_rgb (format)) {
+  } else if (gst_video_format_is_rgb (format)) {
     GstCaps *caps;
     int red_mask;
     int blue_mask;
@@ -508,6 +574,12 @@ gst_video_format_new_caps (GstVideoFormat format, int width, int height,
         depth = 24;
         have_alpha = FALSE;
         break;
+      case GST_VIDEO_FORMAT_RGB16:
+      case GST_VIDEO_FORMAT_BGR16:
+          bpp = 16;
+          depth = 16;
+          have_alpha = FALSE;
+          break;
       default:
         return NULL;
     }
@@ -526,7 +598,8 @@ gst_video_format_new_caps (GstVideoFormat format, int width, int height,
         mask >> (8 * gst_video_format_get_component_offset (format, 2, width,
             height));
 
-    caps = gst_caps_new_simple ("video/x-raw-rgb",
+    caps = gst_caps_new_simple (
+        rowstride ? "video/x-raw-rgb-strided" : "video/x-raw-rgb",
         "bpp", G_TYPE_INT, bpp,
         "depth", G_TYPE_INT, depth,
         "endianness", G_TYPE_INT, G_BIG_ENDIAN,
@@ -543,9 +616,39 @@ gst_video_format_new_caps (GstVideoFormat format, int width, int height,
               height));
       gst_caps_set_simple (caps, "alpha_mask", G_TYPE_INT, alpha_mask, NULL);
     }
-    return caps;
+  } else {
+    return NULL;
+  }
+
+  if (rowstride) {
+    gst_caps_set_simple (caps, "rowstride", G_TYPE_INT, rowstride, NULL);
   }
-  return NULL;
+
+  return caps;
+}
+
+/**
+ * gst_video_format_new_caps:
+ * @format: the #GstVideoFormat describing the raw video format
+ * @width: width of video
+ * @height: height of video
+ * @framerate_n: numerator of frame rate
+ * @framerate_d: denominator of frame rate
+ * @par_n: numerator of pixel aspect ratio
+ * @par_d: denominator of pixel aspect ratio
+ *
+ * Creates a new #GstCaps object based on the parameters provided.
+ *
+ * Since: 0.10.16
+ *
+ * Returns: a new #GstCaps object, or NULL if there was an error
+ */
+GstCaps *
+gst_video_format_new_caps (GstVideoFormat format, int width, int height,
+    int framerate_n, int framerate_d, int par_n, int par_d)
+{
+  return gst_video_format_new_caps_strided (format, width, height, 0,
+      framerate_n, framerate_d, par_n, par_d);
 }
 
 /**
@@ -651,7 +754,7 @@ gst_video_format_to_fourcc (GstVideoFormat format)
  * @blue_mask: blue bit mask
  *
  * Converts red, green, blue bit masks into the corresponding
- * #GstVideoFormat.  
+ * #GstVideoFormat.
  *
  * Since: 0.10.16
  *
@@ -717,6 +820,19 @@ gst_video_format_from_rgb24_masks (int red_mask, int green_mask, int blue_mask)
   return GST_VIDEO_FORMAT_UNKNOWN;
 }
 
+static GstVideoFormat
+gst_video_format_from_rgb16_masks (int red_mask, int green_mask, int blue_mask)
+{
+    if (red_mask == 0xf800 && green_mask == 0x07e0 && blue_mask == 0x001f) {
+        return GST_VIDEO_FORMAT_RGB16;
+    }
+    if (red_mask== 0x001f && green_mask == 0x07e0 && blue_mask == 0xf800) {
+        return GST_VIDEO_FORMAT_BGR16;
+    }
+
+    return GST_VIDEO_FORMAT_UNKNOWN;
+}
+
 /**
  * gst_video_format_is_rgb:
  * @format: a #GstVideoFormat
@@ -755,6 +871,8 @@ gst_video_format_is_rgb (GstVideoFormat format)
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
       return TRUE;
     default:
       return FALSE;
@@ -799,6 +917,8 @@ gst_video_format_is_yuv (GstVideoFormat format)
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
       return FALSE;
     default:
       return FALSE;
@@ -808,7 +928,7 @@ gst_video_format_is_yuv (GstVideoFormat format)
 /**
  * gst_video_format_has_alpha:
  * @format: a #GstVideoFormat
- * 
+ *
  * Returns TRUE or FALSE depending on if the video format provides an
  * alpha channel.
  *
@@ -845,6 +965,8 @@ gst_video_format_has_alpha (GstVideoFormat format)
     case GST_VIDEO_FORMAT_xBGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
       return FALSE;
     default:
       return FALSE;
@@ -902,6 +1024,9 @@ gst_video_format_get_row_stride (GstVideoFormat format, int component,
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
       return GST_ROUND_UP_4 (width * 3);
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
+        return GST_ROUND_UP_4 (width * 2);
     case GST_VIDEO_FORMAT_Y41B:
       if (component == 0) {
         return GST_ROUND_UP_4 (width);
@@ -976,6 +1101,9 @@ gst_video_format_get_pixel_stride (GstVideoFormat format, int component)
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
       return 3;
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
+        return 2;
     case GST_VIDEO_FORMAT_v210:
       /* v210 is packed at the bit level, so pixel stride doesn't make sense */
       return 0;
@@ -1050,6 +1178,8 @@ gst_video_format_get_component_width (GstVideoFormat format, int component,
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
     case GST_VIDEO_FORMAT_Y444:
     case GST_VIDEO_FORMAT_NV12:
     case GST_VIDEO_FORMAT_NV21:
@@ -1107,6 +1237,8 @@ gst_video_format_get_component_height (GstVideoFormat format, int component,
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
     case GST_VIDEO_FORMAT_Y444:
     case GST_VIDEO_FORMAT_v210:
     case GST_VIDEO_FORMAT_v216:
@@ -1244,6 +1376,7 @@ gst_video_format_get_component_offset (GstVideoFormat format, int component,
         return 0;
       return 0;
     case GST_VIDEO_FORMAT_RGB:
+    case GST_VIDEO_FORMAT_RGB16:
       if (component == 0)
         return 0;
       if (component == 1)
@@ -1252,6 +1385,7 @@ gst_video_format_get_component_offset (GstVideoFormat format, int component,
         return 2;
       return 0;
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_BGR16:
       if (component == 0)
         return 2;
       if (component == 1)
@@ -1353,6 +1487,9 @@ gst_video_format_get_size (GstVideoFormat format, int width, int height)
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
       return GST_ROUND_UP_4 (width * 3) * height;
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
+        return GST_ROUND_UP_4 (width * 2) * height;
     case GST_VIDEO_FORMAT_Y41B:
       /* simplification of ROUNDUP4(w)*h + 2*((ROUNDUP8(w)/4)*h */
       return (GST_ROUND_UP_4 (width) + (GST_ROUND_UP_16 (width) / 2)) * height;
@@ -1374,6 +1511,76 @@ gst_video_format_get_size (GstVideoFormat format, int width, int height)
 }
 
 /**
+ * gst_video_format_get_size_strided:
+ * @format: a #GstVideoFormat
+ * @width: the width of video (in pixels)
+ * @height: the height of video (in pixels)
+ * @rowstride: the rowstride (in bytes), or 0 if no rowstride (in which
+ *    case the returned value is same as #gst_video_format_get_size())
+ *
+ * Calculates the total number of bytes in the raw video format, for a buffer
+ * which may have a rowstride in bytes
+ *
+ * Since: ???
+ *
+ * Returns: size (in bytes) of raw video format
+ */
+int
+gst_video_format_get_size_strided (GstVideoFormat format,
+    int width, int height, int rowstride)
+{
+  if(!rowstride)
+    return gst_video_format_get_size (format, width, height);
+
+  g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, 0);
+  g_return_val_if_fail (width > 0 && height > 0, 0);
+
+  switch (format) {
+    /* all packed formats have the same calculation, ie. rowstride * height
+     */
+    case GST_VIDEO_FORMAT_RGBx:
+    case GST_VIDEO_FORMAT_BGRx:
+    case GST_VIDEO_FORMAT_xRGB:
+    case GST_VIDEO_FORMAT_xBGR:
+    case GST_VIDEO_FORMAT_RGBA:
+    case GST_VIDEO_FORMAT_BGRA:
+    case GST_VIDEO_FORMAT_ARGB:
+    case GST_VIDEO_FORMAT_ABGR:
+    case GST_VIDEO_FORMAT_RGB:
+    case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_RGB16:
+    case GST_VIDEO_FORMAT_BGR16:
+    case GST_VIDEO_FORMAT_YUY2:
+    case GST_VIDEO_FORMAT_YVYU:
+    case GST_VIDEO_FORMAT_UYVY:
+    case GST_VIDEO_FORMAT_AYUV:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
+      return GST_ROUND_UP_4 (rowstride * height);
+
+    /* these planar formats have 2x sub-sampling in the vertical direction,
+     * so U/V have half as many rows as Y:
+     */
+    case GST_VIDEO_FORMAT_I420:
+    case GST_VIDEO_FORMAT_YV12:
+      return GST_ROUND_UP_4 (2 * rowstride * height);
+
+    /* these planar formats have no sub-sampling in the vertical direction,
+     * so each plane has 'height' number of rows
+     */
+    case GST_VIDEO_FORMAT_Y41B:
+    case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_Y444:
+      return GST_ROUND_UP_4 (3 * rowstride * height);
+    case GST_VIDEO_FORMAT_NV12:
+    case GST_VIDEO_FORMAT_NV21:
+      return GST_ROUND_UP_4 (rowstride) * GST_ROUND_UP_2 (height) * 3 / 2;
+    default:
+      return 0;
+  }
+}
+
+/**
  * gst_video_format_convert:
  * @format: a #GstVideoFormat
  * @width: the width of video
diff --git a/gst-libs/gst/video/video.h b/gst-libs/gst/video/video.h
index 20946dc..6c44405 100644
--- a/gst-libs/gst/video/video.h
+++ b/gst-libs/gst/video/video.h
@@ -33,7 +33,7 @@ G_BEGIN_DECLS
  * @GST_VIDEO_FORMAT_I420: planar 4:2:0 YUV
  * @GST_VIDEO_FORMAT_YV12: planar 4:2:0 YVU (like I420 but UV planes swapped)
  * @GST_VIDEO_FORMAT_YUY2: packed 4:2:2 YUV (Y0-U0-Y1-V0 Y2-U2-Y3-V2 Y4 ...)
- * @GST_VIDEO_FORMAT_UYVY: packed 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4 ...) 
+ * @GST_VIDEO_FORMAT_UYVY: packed 4:2:2 YUV (U0-Y0-V0-Y1 U2-Y2-V2-Y3 U4 ...)
  * @GST_VIDEO_FORMAT_AYUV: packed 4:4:4 YUV with alpha channel (A0-Y0-U0-V0 ...)
  * @GST_VIDEO_FORMAT_RGBx: sparse rgb packed into 32 bit, space last
  * @GST_VIDEO_FORMAT_BGRx: sparse reverse rgb packed into 32 bit, space last
@@ -72,6 +72,8 @@ typedef enum {
   GST_VIDEO_FORMAT_ARGB,
   GST_VIDEO_FORMAT_ABGR,
   GST_VIDEO_FORMAT_RGB,
+  GST_VIDEO_FORMAT_RGB16,
+  GST_VIDEO_FORMAT_BGR16,
   GST_VIDEO_FORMAT_BGR,
   GST_VIDEO_FORMAT_Y41B,
   GST_VIDEO_FORMAT_Y42B,
@@ -171,13 +173,13 @@ typedef enum {
 
 #define GST_VIDEO_CAPS_RGBx \
     __GST_VIDEO_CAPS_MAKE_32 (1, 2, 3)
-  
+
 #define GST_VIDEO_CAPS_xRGB \
     __GST_VIDEO_CAPS_MAKE_32 (2, 3, 4)
-  
+
 #define GST_VIDEO_CAPS_BGRx \
     __GST_VIDEO_CAPS_MAKE_32 (3, 2, 1)
-  
+
 #define GST_VIDEO_CAPS_xBGR \
     __GST_VIDEO_CAPS_MAKE_32 (4, 3, 2)
 
@@ -185,13 +187,13 @@ typedef enum {
 
 #define GST_VIDEO_CAPS_RGBA \
     __GST_VIDEO_CAPS_MAKE_32A (1, 2, 3, 4)
-  
+
 #define GST_VIDEO_CAPS_ARGB \
     __GST_VIDEO_CAPS_MAKE_32A (2, 3, 4, 1)
-  
+
 #define GST_VIDEO_CAPS_BGRA \
     __GST_VIDEO_CAPS_MAKE_32A (3, 2, 1, 4)
-  
+
 #define GST_VIDEO_CAPS_ABGR \
     __GST_VIDEO_CAPS_MAKE_32A (4, 3, 2, 1)
 
@@ -207,9 +209,9 @@ typedef enum {
   #define GST_VIDEO_CAPS_BGRx_HOST_ENDIAN \
       GST_VIDEO_CAPS_xRGB
 #endif
-      
+
 /* 15/16 bit */
-  
+
 #define GST_VIDEO_CAPS_RGB_16                                           \
             "video/x-raw-rgb, "                                         \
             "bpp = (int) 16, "                                          \
@@ -222,6 +224,20 @@ typedef enum {
             "height = " GST_VIDEO_SIZE_RANGE ", "                       \
             "framerate = " GST_VIDEO_FPS_RANGE
 
+#define GST_VIDEO_CAPS_RGB_16_STRIDED(rowstride)                        \
+			GST_VIDEO_CAPS_RGB_16 ";"									\
+            "video/x-raw-rgb-strided, "                                 \
+			"rowstride = (int) " rowstride ", "                         \
+            "bpp = (int) 16, "                                          \
+            "depth = (int) 16, "                                        \
+            "endianness = (int) BYTE_ORDER, "                           \
+            "red_mask = (int) " GST_VIDEO_RED_MASK_16 ", "              \
+            "green_mask = (int) " GST_VIDEO_GREEN_MASK_16 ", "          \
+            "blue_mask = (int) " GST_VIDEO_BLUE_MASK_16 ", "            \
+            "width = " GST_VIDEO_SIZE_RANGE ", "                        \
+            "height = " GST_VIDEO_SIZE_RANGE ", "                       \
+            "framerate = " GST_VIDEO_FPS_RANGE
+
 #define GST_VIDEO_CAPS_RGB_15                                           \
             "video/x-raw-rgb, "                                         \
             "bpp = (int) 16, "                                          \
@@ -241,6 +257,16 @@ typedef enum {
         "height = " GST_VIDEO_SIZE_RANGE ", "                           \
         "framerate = " GST_VIDEO_FPS_RANGE
 
+
+#define GST_VIDEO_CAPS_YUV_STRIDED(fourcc, rowstride)                   \
+        GST_VIDEO_CAPS_YUV(fourcc) "; "                                 \
+        "video/x-raw-yuv-strided, "                                     \
+        "format = (fourcc) " fourcc ", "                                \
+        "rowstride = (int) " rowstride ", "                             \
+        "width = " GST_VIDEO_SIZE_RANGE ", "                            \
+        "height = " GST_VIDEO_SIZE_RANGE ", "                           \
+        "framerate = " GST_VIDEO_FPS_RANGE
+
 /* buffer flags */
 
 /**
@@ -280,13 +306,15 @@ gboolean gst_video_get_size   (GstPad *pad,
                                gint   *height);
 
 gboolean gst_video_calculate_display_ratio (guint *dar_n, guint *dar_d,
-            guint video_width, guint video_height, 
-            guint video_par_n, guint video_par_d, 
+            guint video_width, guint video_height,
+            guint video_par_n, guint video_par_d,
             guint display_par_n, guint display_par_d);
 
 gboolean gst_video_format_parse_caps (GstCaps *caps, GstVideoFormat *format,
     int *width, int *height);
 gboolean gst_video_format_parse_caps_interlaced (GstCaps *caps, gboolean *interlaced);
+gboolean gst_video_format_parse_caps_strided (GstCaps * caps, GstVideoFormat * format,
+    int *width, int *height, int *rowstride);
 gboolean gst_video_parse_caps_framerate (GstCaps *caps,
     int *fps_n, int *fps_d);
 gboolean gst_video_parse_caps_pixel_aspect_ratio (GstCaps *caps,
@@ -297,6 +325,9 @@ GstCaps * gst_video_format_new_caps (GstVideoFormat format,
 GstCaps * gst_video_format_new_caps_interlaced (GstVideoFormat format,
     int width, int height, int framerate_n, int framerate_d,
 						int par_n, int par_d, gboolean interlaced);
+GstCaps * gst_video_format_new_caps_strided (GstVideoFormat format,
+    int width, int height, int rowstride,
+    int framerate_n, int framerate_d, int par_n, int par_d);
 GstVideoFormat gst_video_format_from_fourcc (guint32 fourcc);
 guint32 gst_video_format_to_fourcc (GstVideoFormat format);
 gboolean gst_video_format_is_rgb (GstVideoFormat format);
@@ -312,6 +343,8 @@ int gst_video_format_get_component_height (GstVideoFormat format, int component,
 int gst_video_format_get_component_offset (GstVideoFormat format, int component,
     int width, int height);
 int gst_video_format_get_size (GstVideoFormat format, int width, int height);
+int gst_video_format_get_size_strided (GstVideoFormat format,
+    int width, int height, int rowstride);
 gboolean gst_video_format_convert (GstVideoFormat format, int width, int height,
     int fps_n, int fps_d,
     GstFormat src_format, gint64 src_value,
diff --git a/gst/audioconvert/Makefile.am b/gst/audioconvert/Makefile.am
index 94978bb..2d273db 100644
--- a/gst/audioconvert/Makefile.am
+++ b/gst/audioconvert/Makefile.am
@@ -5,6 +5,7 @@ libgstaudioconvert_la_SOURCES = \
 	audioconvert.c \
 	gstchannelmix.c \
 	gstaudioquantize.c \
+	armv7.c \
 	plugin.c
 
 libgstaudioconvert_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS)
diff --git a/gst/audioconvert/armv7.c b/gst/audioconvert/armv7.c
new file mode 100644
index 0000000..e39d29d
--- /dev/null
+++ b/gst/audioconvert/armv7.c
@@ -0,0 +1,209 @@
+/* GStreamer
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+ *
+ * Description: NEON/VFP accelerated functions for armv7 architecture
+ *  Created on: Aug 8, 2009
+ *      Author: Rob Clark <rob@ti.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef __ARM_NEON__
+#include <arm_neon.h>
+#include <string.h>
+
+#include "audioconvert.h"
+
+
+void
+gst_audio_quantize_quantize_signed_tpdf_none (AudioConvertCtx *ctx,
+    gint32 *src, gint32 *dst, gint count)
+{
+  static guint32 state[4] = {
+      0xdeadbeef,
+      0x305b8cc9,
+      0x6c46ec93,
+      0xad13b0cd
+  };
+
+  gint scale = ctx->out_scale;
+  count *= ctx->out.channels;
+
+  if (scale > 0) {
+    guint32 mask = 0xffffffff & (0xffffffff << scale);
+    guint32 bias = (1U << (scale - 1)) >> 1;
+    gint32 dither = (1<<(scale - 1));
+
+    int32x4_t  vrand;
+    uint32x4_t vstate;
+    uint32x4_t v12345;
+    int32x4_t  vtmp;
+    uint32x4_t vmask;
+
+    vstate = vld1q_u32 (state);
+    v12345 = vmovq_n_u32 (12345);
+    vmask  = vmovq_n_u32 (mask);
+
+    /* until we have less 4 words less to process, use vector instructions
+     * to do everything 4x at a time:
+     */
+    for (;;count-=4) {
+      int64x2_t  vtmp_lo;
+      int64x2_t  vtmp_hi;
+      uint32x4_t vstate2;
+      int32x2_t  vrand_lo;
+      int32x2_t  vrand_hi;
+
+      /* generate next eight random words: (see gst_fast_random_uint32())
+       *
+       *    state = state * 1103515245 + 12345
+       */
+      vstate2 = vmulq_n_u32 (vstate, 1103515245);
+      vstate2 = vaddq_u32 (vstate2, v12345);
+      vstate  = vmulq_n_u32 (vstate2, 1103515245);
+      vstate  = vaddq_u32 (vstate2, v12345);
+
+      /* generate next four scaled random values:
+       *
+       *    gint32 start = bias - dither;
+       *    gint32 end = bias + dither - 1;
+       *    gint64 tmp1 = gst_fast_random_uint32 ();
+       *    gint64 tmp2 = gst_fast_random_uint32 ();
+       *    rand = (gint32)(((tmp1+tmp2) * (end - start)) / (1LLU<<32) + start);
+       *
+       * need to split vstate and vstate2 into 2*2 int64x2_t and add....
+       */
+      vstate2 = vaddq_u32 (vstate, vstate2);     /* tmp1+tmp2 */
+      vtmp_lo = vreinterpretq_s64_u64 (          /* * (end-start) */
+          vmull_n_u32 (vget_low_u32 (vstate2), (2*dither) - 1));
+      vtmp_hi = vreinterpretq_s64_u64 (          /* * (end-start) */
+          vmull_n_u32 (vget_high_u32 (vstate2), (2*dither) - 1));
+
+      vtmp_lo = vshrq_n_s64 (vtmp_lo, 32);       /* / (1LLU<<32) */
+      vtmp_hi = vshrq_n_s64 (vtmp_hi, 32);       /* / (1LLU<<32) */
+
+
+      /* now want to put vtmp_hi and vtmp_lo back together..
+       * then add 'start' (bias-dither).. which is negative..
+       */
+      vrand_lo = vmovn_s64 (vtmp_lo);
+      vrand_hi = vmovn_s64 (vtmp_hi);
+      vrand    = vcombine_s32 (vrand_lo, vrand_hi);
+      vrand    = vaddq_s32 (vrand, vmovq_n_s32 (bias-dither));
+
+      /* load next 4 words:
+       */
+      vtmp = vld1q_s32 (src);
+      src += 4;
+
+      /* perform saturating add of random noise... we don't want the
+       * value to wrap around:
+       *
+       * XXX I *think* vqaddq will handle saturation for underflow too..
+       */
+      vtmp = vqaddq_s32 (vtmp, vrand);
+      vtmp = vreinterpretq_s32_u32 (
+          vandq_u32 (vreinterpretq_u32_s32 (vtmp), vmask));
+
+      /* we check for less than four remaining words at the end, before
+       * we store the result back.. the assumption is that it shouldn't
+       * cause a segfault to read past the end of 'src', and there is no
+       * harm in processing a few garbage words.  But we definitely don't
+       * want to write past the end of 'dst'
+       */
+      if (count<4) break;
+
+      /* store 4 words to result:
+       */
+      vst1q_s32 (dst, vtmp);
+      dst += 4;
+    }
+
+    vst1q_u32 (state, vstate);
+
+    /* at this point, we could have 0-3 result bytes in vtmp to write
+     * back out to 'dst':
+     */
+    if (count) {
+      gint32 tmpdst[4];
+      gint32 *tmpp = tmpdst;
+
+      vst1q_s32 (tmpdst, vtmp);
+
+      while (count--) {
+        *dst++ = *tmpp++;
+      }
+    }
+
+  } else {
+    memmove (dst, src, count);
+  }
+}
+
+void
+gst_audio_convert_unpack_float_le (gfloat * src, gint32 * dst, gint s, gint count)
+{
+  float32x4_t vsrc;
+  float32x4_t v05;
+  int32x4_t   vdst;
+
+  v05 = vmovq_n_f32 (0.5);
+
+  for (;;count-=4) {
+
+    /* load next 4 words:
+     */
+    vsrc = vld1q_f32 ((float32_t *)src);
+    src += 4;
+
+    /* convert to int:
+     */
+    vsrc = vmulq_n_f32 (vsrc, 2147483647.0);
+    vsrc = vaddq_f32 (vsrc, v05);
+    vdst = vcvtq_s32_f32 (vsrc);
+
+    /* we check for less than four remaining words at the end, before
+     * we store the result back.. the assumption is that it shouldn't
+     * cause a segfault to read past the end of 'src', and there is no
+     * harm in processing a few garbage words.  But we definitely don't
+     * want to write past the end of 'dst'
+     */
+    if (count<4) break;
+
+    /* store 4 words to result:
+     */
+    vst1q_s32 (dst, vdst);
+    dst += 4;
+  }
+
+  /* at this point, we could have 0-3 result bytes in vtmp to write
+   * back out to 'dst':
+   */
+  if (count) {
+    gint32 tmpdst[4];
+    gint32 *tmpp = tmpdst;
+
+    vst1q_s32 (tmpdst, vdst);
+
+    while (count--) {
+      *dst++ = *tmpp++;
+    }
+  }
+}
+
+
+#endif
diff --git a/gst/audioconvert/audioconvert.c b/gst/audioconvert/audioconvert.c
index 4780324..c18d217 100644
--- a/gst/audioconvert/audioconvert.c
+++ b/gst/audioconvert/audioconvert.c
@@ -38,11 +38,11 @@
  * unpack code
  */
 #define MAKE_UNPACK_FUNC_NAME(name)                                     \
-audio_convert_unpack_##name
+gst_audio_convert_unpack_##name
 
 /* unpack from integer to signed integer 32 */
 #define MAKE_UNPACK_FUNC_II(name, stride, sign, READ_FUNC)              \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_UNPACK_FUNC_NAME (name) (guint8 *src, gint32 *dst,                 \
         gint scale, gint count)                                         \
 {                                                                       \
@@ -54,7 +54,7 @@ MAKE_UNPACK_FUNC_NAME (name) (guint8 *src, gint32 *dst,                 \
 
 /* unpack from float to signed integer 32 */
 #define MAKE_UNPACK_FUNC_FI(name, type, READ_FUNC)                            \
-static void                                                                   \
+void __attribute__((weak))                                                    \
 MAKE_UNPACK_FUNC_NAME (name) (type * src, gint32 * dst, gint s, gint count)   \
 {                                                                             \
   gdouble temp;                                                               \
@@ -68,7 +68,7 @@ MAKE_UNPACK_FUNC_NAME (name) (type * src, gint32 * dst, gint s, gint count)   \
 
 /* unpack from float to float 64 (double) */
 #define MAKE_UNPACK_FUNC_FF(name, type, FUNC)                                 \
-static void                                                                   \
+void __attribute__((weak))                                                    \
 MAKE_UNPACK_FUNC_NAME (name) (type * src, gdouble * dst, gint s,              \
     gint count)                                                               \
 {                                                                             \
@@ -78,7 +78,7 @@ MAKE_UNPACK_FUNC_NAME (name) (type * src, gdouble * dst, gint s,              \
 
 /* unpack from int to float 64 (double) */
 #define MAKE_UNPACK_FUNC_IF(name, stride, sign, READ_FUNC)                    \
-static void                                                                   \
+void __attribute__((weak))                                                    \
 MAKE_UNPACK_FUNC_NAME (name) (guint8 * src, gdouble * dst, gint scale,        \
     gint count)                                                               \
 {                                                                             \
@@ -158,7 +158,7 @@ audio_convert_pack_##name
 
 /* pack from signed integer 32 to integer */
 #define MAKE_PACK_FUNC_II(name, stride, sign, WRITE_FUNC)               \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_PACK_FUNC_NAME (name) (gint32 *src, guint8 * dst,                  \
         gint scale, gint count)                                         \
 {                                                                       \
@@ -172,7 +172,7 @@ MAKE_PACK_FUNC_NAME (name) (gint32 *src, guint8 * dst,                  \
 
 /* pack from signed integer 32 to float */
 #define MAKE_PACK_FUNC_IF(name, type, FUNC)                             \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_PACK_FUNC_NAME (name) (gint32 * src, type * dst, gint scale,       \
     gint count)                                                         \
 {                                                                       \
@@ -182,7 +182,7 @@ MAKE_PACK_FUNC_NAME (name) (gint32 * src, type * dst, gint scale,       \
 
 /* pack from float 64 (double) to float */
 #define MAKE_PACK_FUNC_FF(name, type, FUNC)                             \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_PACK_FUNC_NAME (name) (gdouble * src, type * dst, gint s,          \
     gint count)                                                         \
 {                                                                       \
@@ -194,7 +194,7 @@ MAKE_PACK_FUNC_NAME (name) (gdouble * src, type * dst, gint s,          \
  * the floats are already in the correct range. Only a cast is needed.
  */
 #define MAKE_PACK_FUNC_FI_S(name, stride, WRITE_FUNC)                   \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_PACK_FUNC_NAME (name) (gdouble * src, guint8 * dst, gint scale,    \
     gint count)                                                         \
 {                                                                       \
@@ -212,7 +212,7 @@ MAKE_PACK_FUNC_NAME (name) (gdouble * src, guint8 * dst, gint scale,    \
  * and an addition of 2^(target_depth-1) to get in the correct unsigned
  * range. */
 #define MAKE_PACK_FUNC_FI_U(name, stride, WRITE_FUNC)                   \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_PACK_FUNC_NAME (name) (gdouble * src, guint8 * dst, gint scale,    \
     gint count)                                                         \
 {                                                                       \
diff --git a/gst/audioconvert/gstaudioquantize.c b/gst/audioconvert/gstaudioquantize.c
index 2155397..be959c4 100644
--- a/gst/audioconvert/gstaudioquantize.c
+++ b/gst/audioconvert/gstaudioquantize.c
@@ -46,7 +46,7 @@ gst_audio_quantize_quantize_##name
 
 #define MAKE_QUANTIZE_FUNC_I(name, DITHER_INIT_FUNC, ADD_DITHER_FUNC,   \
                              ROUND_FUNC)                                \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_QUANTIZE_FUNC_NAME (name) (AudioConvertCtx *ctx, gint32 *src,      \
                                 gint32 *dst, gint count)                \
 {                                                                       \
@@ -86,7 +86,7 @@ MAKE_QUANTIZE_FUNC_NAME (name) (AudioConvertCtx *ctx, gint32 *src,      \
 #define MAKE_QUANTIZE_FUNC_F(name, DITHER_INIT_FUNC, NS_INIT_FUNC,      \
                              ADD_NS_FUNC, ADD_DITHER_FUNC,              \
                              UPDATE_ERROR_FUNC)                         \
-static void                                                             \
+void __attribute__((weak))                                              \
 MAKE_QUANTIZE_FUNC_NAME (name) (AudioConvertCtx *ctx, gdouble *src,     \
                                 gdouble *dst, gint count)               \
 {                                                                       \
diff --git a/gst/audioconvert/gstchannelmix.c b/gst/audioconvert/gstchannelmix.c
index 055f28d..ea7c4a0 100644
--- a/gst/audioconvert/gstchannelmix.c
+++ b/gst/audioconvert/gstchannelmix.c
@@ -663,7 +663,7 @@ gst_channel_mix_passthrough (AudioConvertCtx * this)
 
 /* IMPORTANT: out_data == in_data is possible, make sure to not overwrite data
  * you might need later on! */
-void
+void __attribute__((weak))
 gst_channel_mix_mix_int (AudioConvertCtx * this,
     gint32 * in_data, gint32 * out_data, gint samples)
 {
@@ -702,7 +702,7 @@ gst_channel_mix_mix_int (AudioConvertCtx * this,
   }
 }
 
-void
+void __attribute__((weak))
 gst_channel_mix_mix_float (AudioConvertCtx * this,
     gdouble * in_data, gdouble * out_data, gint samples)
 {
diff --git a/gst/stride/Makefile.am b/gst/stride/Makefile.am
new file mode 100644
index 0000000..3b466de
--- /dev/null
+++ b/gst/stride/Makefile.am
@@ -0,0 +1,17 @@
+plugin_LTLIBRARIES = libgststridetransform.la
+
+libgststridetransform_la_SOURCES = \
+	gststridetransform.c \
+	convert.c \
+	armv7.s \
+	plugin.c
+
+libgststridetransform_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_BASE_CFLAGS) $(GST_CFLAGS)
+libgststridetransform_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgststridetransform_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/video/libgstvideo-@GST_MAJORMINOR@.la \
+	$(GST_BASE_LIBS) $(GST_LIBS) $(LIBM)
+libgststridetransform_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = \
+	gststridetransform.h
diff --git a/gst/stride/armv7.s b/gst/stride/armv7.s
new file mode 100644
index 0000000..2697a14
--- /dev/null
+++ b/gst/stride/armv7.s
@@ -0,0 +1,182 @@
+@ GStreamer
+@
+@ Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+@
+@ Description: NEON/VFP accelerated functions for armv7 architecture
+@  Created on: Nov 27, 2009
+@      Author: Rob Clark <rob@ti.com>
+@
+@ This library is free software; you can redistribute it and/or
+@ modify it under the terms of the GNU Library General Public
+@ License as published by the Free Software Foundation; either
+@ version 2 of the License, or (at your option) any later version.
+@
+@ This library is distributed in the hope that it will be useful,
+@ but WITHOUT ANY WARRANTY; without even the implied warranty of
+@ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+@ Library General Public License for more details.
+@
+@ You should have received a copy of the GNU Library General Public
+@ License along with this library; if not, write to the
+@ Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+@ Boston, MA 02111-1307, USA.
+
+       .fpu neon
+       .text
+
+       .align
+       .global stride_copy_zip2
+       .type   stride_copy_zip2, %function
+@void
+@stride_copy_zip2 (guchar *new_buf, guchar *orig_buf1, guchar *orig_buf2, gint sz)
+@{
+@@@@ note: r0-r3, q0-3, and q8-q15 do not need to be preserved
+stride_copy_zip2:
+@ interleave remaining >= 16 bytes:
+       pld [r1, #64]
+       pld [r2, #64]
+       cmp r3, #16
+       blt stride_copy_zip2_2
+stride_copy_zip2_1:
+       vld1.8 {q8}, [r1]!
+       vld1.8 {q9}, [r2]!
+
+       vzip.8 q8, q9
+
+       pld [r1, #64]
+       vst1.8 {q8,q9}, [r0]!
+       pld [r2, #64]
+       sub r3, r3, #16
+
+       cmp r3, #16
+       bge stride_copy_zip2_1
+@ interleave remaining >= 8 bytes:
+stride_copy_zip2_2:
+       cmp r3, #8
+       blt stride_copy_zip2_3
+
+       vld1.8 {d16}, [r1]!
+       vld1.8 {d17}, [r2]!
+
+       vzip.8 d16, d17
+
+       vst1.8 {d16,d17}, [r0]!
+       sub r3, r3, #8
+
+@ interleave remaining < 8 bytes:
+stride_copy_zip2_3:
+@XXX
+       bx lr
+@}
+
+
+       .align
+       .global stride_copy_zip3a
+       .type   stride_copy_zip3a, %function
+@void
+@stride_copy_zip3a (guchar *new_buf,
+@    guchar *orig_buf1, guchar *orig_buf2, guchar *orig_buf3, gint sz)
+@{
+@@@@ note: r0-r3, q0-3, and q8-q15 do not need to be preserved
+stride_copy_zip3a:
+       pld [r1, #64]
+       pld [r2, #64]
+       pld [r3, #64]
+       ldr ip, [sp]     @ the sz arg
+@ interleave remaining >= 32 bytes:
+       cmp ip, #32
+       blt stride_copy_zip3a_2
+stride_copy_zip3a_1:
+       vld1.8 {q8},      [r1]!  @ Y
+       vld1.8 {q10},     [r1]!  @ Y
+       vld1.8 {q9},      [r2]!  @ U
+       vld1.8 {q11},     [r3]!  @ V
+
+       pld [r1, #64]
+       pld [r2, #64]
+       pld [r3, #64]
+
+       vzip.8 q9, q11           @ interleave U&V
+       vzip.8 q8, q9            @ interleave Y1UV1
+       vzip.8 q10, q11          @ interleave Y2UV2
+
+       vst1.8 {q8,q9},   [r0]!
+       vst1.8 {q10,q11}, [r0]!
+
+       sub ip, ip, #32
+
+       cmp ip, #32
+       bge stride_copy_zip3a_1
+@ interleave remaining >= 16 bytes:
+stride_copy_zip3a_2:
+       cmp ip, #16
+       blt stride_copy_zip3a_3
+
+       vld1.8 {d16},     [r1]!  @ Y
+       vld1.8 {d18},     [r1]!  @ Y
+       vld1.8 {d17},     [r2]!  @ U
+       vld1.8 {d19},     [r3]!  @ V
+
+       vzip.8 d17, d19          @ interleave U&V
+       vzip.8 d16, d17          @ interleave Y1UV1
+       vzip.8 d18, d19          @ interleave Y2UV2
+
+       vst1.8 {d16,d17}, [r0]!
+       vst1.8 {d18,d19}, [r0]!
+
+       sub ip, ip, #16
+@ copy remaining >= 8 bytes:
+stride_copy_zip3a_3:
+@XXX
+       bx lr
+@}
+
+
+       .align
+       .global stride_copy
+       .type   stride_copy, %function
+@void
+@stride_copy (guchar *new_buf, guchar *orig_buf, gint sz)
+@{
+@@@@ note: r0-r3, q0-3, and q8-q15 do not need to be preserved
+stride_copy:
+@ copy remaining >= 64 bytes:
+       pld [r1, #64]
+       cmp r2, #64
+       blt stride_copy_2
+stride_copy_1:
+       vld1.8 {q8-q9},  [r1]!
+       sub r2, r2, #64
+       vld1.8 {q10-q11},[r1]!
+       vst1.8 {q8-q9},  [r0]!
+       pld [r1, #64]
+       cmp r2, #64
+       vst1.8 {q10-q11},[r0]!
+       bge stride_copy_1
+@ copy remaining >= 32 bytes:
+stride_copy_2:
+       cmp r2, #32
+       blt stride_copy_3
+       vld1.8 {q8-q9}, [r1]!
+       sub r2, r2, #32
+       vst1.8 {q8-q9}, [r0]!
+@ copy remaining >= 16 bytes:
+stride_copy_3:
+       cmp r2, #16
+       blt stride_copy_4
+       vld1.8 {q8}, [r1]!
+       sub r2, r2, #16
+       vst1.8 {q8}, [r0]!
+@ copy remaining >= 8 bytes:
+stride_copy_4:
+       cmp r2, #8
+       blt stride_copy_5
+       vld1.8 {d16}, [r1]!
+       sub r2, r2, #8
+       vst1.8 {d16}, [r0]!
+@ copy remaining < 8 bytes:
+stride_copy_5:
+@XXX
+       bx lr
+@}
+
diff --git a/gst/stride/convert.c b/gst/stride/convert.c
new file mode 100644
index 0000000..dfe65c7
--- /dev/null
+++ b/gst/stride/convert.c
@@ -0,0 +1,371 @@
+/* GStreamer
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+ *
+ * Description: stride transform conversion utilities
+ *  Created on: Nov 27, 2009
+ *      Author: Rob Clark <rob@ti.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <gst/video/video.h>
+
+#include "gststridetransform.h"
+
+
+GST_DEBUG_CATEGORY_EXTERN (stridetransform_debug);
+#define GST_CAT_DEFAULT stridetransform_debug
+
+
+/* note: some parts of code support in-place transform.. some do not..  I'm
+ * not sure if zip/interleave functions could really support in-place copy..
+ * I need to think about this after having some sleep ;-)
+ */
+
+#define WEAK __attribute__((weak))
+
+/*
+ * Conversion utilities:
+ */
+
+WEAK void
+stride_copy_zip2 (guchar * new_buf, guchar * orig_buf1, guchar * orig_buf2,
+    gint sz)
+{
+  while (sz--) {
+    *new_buf++ = *orig_buf1++;
+    *new_buf++ = *orig_buf2++;
+  }
+}
+
+WEAK void
+stride_copy_zip3a (guchar * new_buf,
+    guchar * orig_buf1, guchar * orig_buf2, guchar * orig_buf3, gint sz)
+{
+  while (sz > 1) {
+    *new_buf++ = *orig_buf1++;
+    *new_buf++ = *orig_buf2++;
+    *new_buf++ = *orig_buf1++;
+    *new_buf++ = *orig_buf3++;
+    sz -= 2;
+  }
+}
+
+WEAK void
+stride_copy (guchar * new_buf, guchar * orig_buf, gint sz)
+{
+  memcpy (new_buf, orig_buf, sz);
+}
+
+
+/**
+ * move to strided buffer, interleaving two planes of identical dimensions
+ */
+static void
+stridemove_zip2 (guchar * new_buf, guchar * orig_buf1, guchar * orig_buf2,
+    gint new_width, gint orig_width, gint height)
+{
+  int row;
+
+  GST_DEBUG
+      ("new_buf=%p, orig_buf1=%p, orig_buf2=%p, new_width=%d, orig_width=%d, height=%d",
+      new_buf, orig_buf1, orig_buf2, new_width, orig_width, height);
+
+  /* if increasing the stride, work from bottom-up to avoid overwriting data
+   * that has not been moved yet.. otherwise, work in the opposite order,
+   * for the same reason.
+   */
+  if (new_width > orig_width) {
+    for (row = height - 1; row >= 0; row--) {
+      stride_copy_zip2 (new_buf + (new_width * row),
+          orig_buf1 + (orig_width * row),
+          orig_buf2 + (orig_width * row), orig_width);
+    }
+  } else {
+    for (row = 0; row < height; row++) {
+      stride_copy_zip2 (new_buf + (new_width * row),
+          orig_buf1 + (orig_width * row),
+          orig_buf2 + (orig_width * row), new_width);
+    }
+  }
+}
+
+/**
+ * move to strided buffer, interleaving three planes, where the first plane
+ * (orig_buf1) has 2x as many samples.. Ie. ABACABAC..
+ */
+static void
+stridemove_zip3a (guchar * new_buf,
+    guchar * orig_buf1, guchar * orig_buf2, guchar * orig_buf3,
+    guint new_width, gint orig_width, gint height)
+{
+  gint copy_width = (new_width < orig_width) ? new_width : orig_width;
+
+  while (height > 0) {
+
+    /* even row */
+    stride_copy_zip3a (new_buf, orig_buf1, orig_buf2, orig_buf3, copy_width);
+    new_buf += new_width;
+    orig_buf1 += orig_width;
+
+    /* odd row, recycles same U & V */
+    stride_copy_zip3a (new_buf, orig_buf1, orig_buf2, orig_buf3, copy_width);
+    new_buf += new_width;
+    orig_buf1 += orig_width;
+
+    orig_buf2 += orig_width / 2;
+    orig_buf3 += orig_width / 2;
+
+    height -= 2;
+  }
+}
+
+/**
+ * Convert from one stride to another... like memmove, but can convert stride in
+ * the process.  This function is not aware of pixels, only of bytes.  So widths
+ * are given in bytes, not pixels.  The new_buf and orig_buf can point to the
+ * same buffers to do an in-place conversion, but the buffer should be large
+ * enough.
+ */
+static void
+stridemove (guchar * new_buf, guchar * orig_buf, gint new_width,
+    gint orig_width, gint height)
+{
+  int row;
+
+  GST_DEBUG ("new_buf=%p, orig_buf=%p, new_width=%d, orig_width=%d, height=%d",
+      new_buf, orig_buf, new_width, orig_width, height);
+
+  /* if increasing the stride, work from bottom-up to avoid overwriting data
+   * that has not been moved yet.. otherwise, work in the opposite order,
+   * for the same reason.
+   */
+  if (new_width > orig_width) {
+    for (row = height - 1; row >= 0; row--) {
+      stride_copy (new_buf + (new_width * row), orig_buf + (orig_width * row),
+          orig_width);
+    }
+  } else {
+    for (row = 0; row < height; row++) {
+      stride_copy (new_buf + (new_width * row), orig_buf + (orig_width * row),
+          new_width);
+    }
+  }
+}
+
+/*
+ * Conversion Functions:
+ */
+
+/** convert 4:2:0 semiplanar to same 4:2:0 semiplanar */
+static GstFlowReturn
+unstridify_420sp_420sp (GstStrideTransform * self, guchar * unstrided,
+    guchar * strided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->in_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  stridemove (unstrided, strided, width, stride,
+      (GST_ROUND_UP_2 (height) * 3) / 2);
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+stridify_420sp_420sp (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+  stridemove (strided, unstrided, stride, width,
+      (GST_ROUND_UP_2 (height) * 3) / 2);
+
+  return GST_FLOW_OK;
+}
+
+/** convert 4:2:0 planar to same 4:2:0 planar */
+static GstFlowReturn
+unstridify_420p_420p (GstStrideTransform * self, guchar * unstrided,
+    guchar * strided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->in_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  stridemove (unstrided, strided, width, stride, height);       /* move Y */
+  stridemove (unstrided + (height * width), strided + (height * stride), width / 2, stride, height);    /* move V/U */
+  /* XXX odd widths/heights/strides: */
+  stridemove (unstrided + (int) (height * width * 1.5), strided + (int) (height * stride * 1.5), width / 2, stride, height);    /* move U/V */
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+stridify_420p_420p (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  /* XXX odd widths/heights/strides: */
+  stridemove (strided + (int) (height * stride * 1.5), unstrided + (int) (height * width * 1.5), stride, width / 2, height);    /* move U/V */
+  stridemove (strided + (height * stride), unstrided + (height * width), stride, width / 2, height);    /* move V/U */
+  stridemove (strided, unstrided, stride, width, height);       /* move Y */
+
+  return GST_FLOW_OK;
+}
+
+/** convert 4:2:2 packed to same 4:2:2 packed */
+static GstFlowReturn
+unstridify_422i_422i (GstStrideTransform * self, guchar * unstrided,
+    guchar * strided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->in_rowstride;
+
+  g_return_val_if_fail (stride >= (width * 2), GST_FLOW_ERROR);
+
+  stridemove (unstrided, strided, width * 2, stride, height);
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+stridify_422i_422i (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= (width * 2), GST_FLOW_ERROR);
+
+  stridemove (strided, unstrided, stride, width * 2, height);
+
+  return GST_FLOW_OK;
+}
+
+/** convert I420 unstrided to NV12 strided */
+static GstFlowReturn
+stridify_i420_nv12 (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  /* XXX widths/heights/strides that are not multiple of four??: */
+  stridemove_zip2 (strided + (height * stride), unstrided + (height * width),   /* U */
+      unstrided + (int) (height * width * 1.25),        /* V */
+      stride, width / 2, height / 2);
+  stridemove (strided, unstrided, stride, width, height);       /* Y */
+
+  return GST_FLOW_OK;
+}
+
+/** convert I420 unstrided to YUY2 strided */
+static GstFlowReturn
+stridify_i420_yuy2 (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= width, GST_FLOW_ERROR);
+
+  /* XXX widths/heights/strides that are not multiple of four??: */
+  stridemove_zip3a (strided, unstrided, /* Y */
+      unstrided + (height * width),     /* U */
+      unstrided + (int) (height * width * 1.25),        /* V */
+      stride, width, height);
+
+  return GST_FLOW_OK;
+}
+
+/** convert RGB565 to RGB565 strided **/
+static GstFlowReturn
+stridify_rgb565_rgb565 (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->out_rowstride;
+
+  g_return_val_if_fail (stride >= (width * 2), GST_FLOW_ERROR);
+
+  stridemove (strided, unstrided, stride, width * 2, height);
+
+  return GST_FLOW_OK;
+}
+
+/** convert RGB565 strided to RGB565 **/
+static GstFlowReturn
+unstridify_rgb565_rgb565 (GstStrideTransform * self, guchar * strided,
+    guchar * unstrided)
+{
+  gint width = self->width;
+  gint height = self->height;
+  gint stride = self->in_rowstride;
+
+  g_return_val_if_fail (stride >= (width * 2), GST_FLOW_ERROR);
+
+  stridemove (unstrided, strided, width * 2, stride, height);
+  return GST_FLOW_OK;
+}
+
+#define CONVERT(tofmt, fromfmt, stridify, unstridify)           \
+		{                                                           \
+      { GST_VIDEO_FORMAT_##tofmt, GST_VIDEO_FORMAT_##fromfmt }, \
+      stridify, unstridify                                      \
+    }
+
+/* last entry has GST_VIDEO_FORMAT_UNKNOWN for in/out formats */
+const Conversion stride_conversions[] = {
+  CONVERT (NV12, NV12, stridify_420sp_420sp, unstridify_420sp_420sp),
+  CONVERT (I420, I420, stridify_420p_420p, unstridify_420p_420p),
+  CONVERT (YV12, YV12, stridify_420p_420p, unstridify_420p_420p),
+  CONVERT (YUY2, YUY2, stridify_422i_422i, unstridify_422i_422i),
+  CONVERT (UYVY, UYVY, stridify_422i_422i, unstridify_422i_422i),
+  CONVERT (I420, NV12, stridify_i420_nv12, NULL),
+  CONVERT (I420, YUY2, stridify_i420_yuy2, NULL),
+  CONVERT (RGB16, RGB16, stridify_rgb565_rgb565, unstridify_rgb565_rgb565),
+  /* add new entries before here */
+  {{GST_VIDEO_FORMAT_UNKNOWN}}
+};
diff --git a/gst/stride/gststridetransform.c b/gst/stride/gststridetransform.c
new file mode 100644
index 0000000..ca04980
--- /dev/null
+++ b/gst/stride/gststridetransform.c
@@ -0,0 +1,426 @@
+/* GStreamer
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+ *
+ * Description: stride transform element
+ *  Created on: Jul 30, 2009
+ *      Author: Rob Clark <rob@ti.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+/**
+ * SECTION:element-stridetransform
+ *
+ * stridetransform can be used to convert between video buffers
+ * with and without stride, or between buffers with differing
+ * stride
+ *
+ * <refsect2>
+ * <title>Example launch lines</title>
+ * |[
+ * gst-launch videotestsrc ! video/x-raw-yuv,format=(fourcc)YUY2,width=320,height=240,framerate=30/1 !
+ * stridetransform ! video/x-raw-yuv-strided,format=(fourcc)YUY2,width=320,height=240,rowstride=700,framerate=30/1 !
+ * stridetransform ! video/x-raw-yuv,format=(fourcc)YUY2,width=320,height=240,framerate=30/1 !
+ * v4l2sink
+ * ]| This pipeline ???? TODO
+ * </refsect2>
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+
+#include <gst/video/video.h>
+
+#include "gst/gst-i18n-plugin.h"
+#include "gststridetransform.h"
+
+
+/* Lets see if we can concatenate two sets of caps */
+char *s;                        /* where the caps will be placed */
+
+/* last entry has GST_VIDEO_FORMAT_UNKNOWN for in/out formats */
+extern const Conversion stride_conversions[];
+
+
+static const GstElementDetails stridetransform_details =
+GST_ELEMENT_DETAILS ("Stride transform",
+    "Filter/Converter/Video",
+    "Convert between video buffers with and without stride, or with differing stride",
+    "Rob Clark <rob@ti.com>,");
+
+
+/* TODO: add rgb formats too! */
+#define YUV_SUPPORTED_CAPS                                                        \
+  GST_VIDEO_CAPS_YUV_STRIDED ("{I420, YV12, YUY2, UYVY, NV12 }", "[ 0, max ]")
+
+#define RGB_SUPPORTED_CAPS                                                        \
+  GST_VIDEO_CAPS_RGB_16_STRIDED ("[ 0, max ]")
+
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (YUV_SUPPORTED_CAPS ";" RGB_SUPPORTED_CAPS)
+    );
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (YUV_SUPPORTED_CAPS ";" RGB_SUPPORTED_CAPS)
+    );
+
+
+GST_DEBUG_CATEGORY (stridetransform_debug);
+#define GST_CAT_DEFAULT stridetransform_debug
+
+/* type functions */
+static void gst_stride_transform_dispose (GObject * obj);
+
+/* GstBaseTransform functions */
+static gboolean gst_stride_transform_get_unit_size (GstBaseTransform * base,
+    GstCaps * caps, guint * size);
+static gboolean gst_stride_transform_transform_size (GstBaseTransform * base,
+    GstPadDirection direction,
+    GstCaps * caps, guint size, GstCaps * othercaps, guint * othersize);
+static GstCaps *gst_stride_transform_transform_caps (GstBaseTransform * base,
+    GstPadDirection direction, GstCaps * caps);
+static gboolean gst_stride_transform_set_caps (GstBaseTransform * base,
+    GstCaps * incaps, GstCaps * outcaps);
+static GstFlowReturn gst_stride_transform_transform (GstBaseTransform * base,
+    GstBuffer * inbuf, GstBuffer * outbuf);
+
+GST_BOILERPLATE (GstStrideTransform, gst_stride_transform, GstVideoFilter,
+    GST_TYPE_VIDEO_FILTER);
+
+
+static void
+gst_stride_transform_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (stridetransform_debug, "stride", 0,
+      "stride transform element");
+
+  gst_element_class_set_details (gstelement_class, &stridetransform_details);
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&sink_template));
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&src_template));
+}
+
+static void
+gst_stride_transform_class_init (GstStrideTransformClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstBaseTransformClass *basetransform_class = GST_BASE_TRANSFORM_CLASS (klass);
+
+  gobject_class->dispose = gst_stride_transform_dispose;
+
+  basetransform_class->get_unit_size =
+      GST_DEBUG_FUNCPTR (gst_stride_transform_get_unit_size);
+  basetransform_class->transform_size =
+      GST_DEBUG_FUNCPTR (gst_stride_transform_transform_size);
+  basetransform_class->transform_caps =
+      GST_DEBUG_FUNCPTR (gst_stride_transform_transform_caps);
+  basetransform_class->set_caps =
+      GST_DEBUG_FUNCPTR (gst_stride_transform_set_caps);
+  basetransform_class->transform =
+      GST_DEBUG_FUNCPTR (gst_stride_transform_transform);
+
+  basetransform_class->passthrough_on_same_caps = TRUE;
+}
+
+static void
+gst_stride_transform_init (GstStrideTransform * self,
+    GstStrideTransformClass * klass)
+{
+  GST_DEBUG_OBJECT (self, "ENTER");
+  self->cached_caps[0] = NULL;
+  self->cached_caps[1] = NULL;
+}
+
+
+static void
+gst_stride_transform_dispose (GObject * object)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (object);
+  GST_DEBUG_OBJECT (self, "ENTER");
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+/**
+ * figure out the required buffer size based on @caps
+ */
+static gboolean
+gst_stride_transform_get_unit_size (GstBaseTransform * base,
+    GstCaps * caps, guint * size)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (base);
+  GstVideoFormat format;
+  gint width, height, rowstride;
+
+  g_return_val_if_fail (gst_video_format_parse_caps_strided (caps, &format,
+          &width, &height, &rowstride), FALSE);
+
+  *size = gst_video_format_get_size_strided (format, width, height, rowstride);
+
+  GST_DEBUG_OBJECT (self,
+      "format=%d, width=%d, height=%d, rowstride=%d -> size=%d",
+      format, width, height, rowstride, *size);
+
+  return TRUE;
+}
+
+/**
+ * Default transform_size function is no good, as it assumes that the output
+ * buffer size is a multiple of the unit size.. which doesn't hold true.
+ */
+static gboolean
+gst_stride_transform_transform_size (GstBaseTransform * base,
+    GstPadDirection direction,
+    GstCaps * caps, guint size, GstCaps * othercaps, guint * othersize)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (base);
+  guint idx = (direction == GST_PAD_SINK) ? 0 : 1;
+
+  if (self->cached_caps[idx] != othercaps) {
+    guint sz;
+    if (!gst_stride_transform_get_unit_size (base, othercaps, &sz)) {
+      return FALSE;
+    }
+    if (self->cached_caps[idx]) {
+      gst_caps_unref (self->cached_caps[idx]);
+    }
+    self->cached_size[idx] = sz;
+    self->cached_caps[idx] = gst_caps_ref (othercaps);
+  }
+
+  *othersize = self->cached_size[idx];
+
+  return TRUE;
+}
+
+/**
+ * helper to check possible @fourcc conversions to the list @formats
+ */
+static void
+add_all_fourcc_conversions (GValue * formats, guint32 fourcc,
+    GstPadDirection direction)
+{
+  gint to_format = (direction == GST_PAD_SINK) ? 1 : 0;
+  gint from_format = (direction == GST_PAD_SRC) ? 1 : 0;
+  GValue fourccval = { 0 };
+  gint i;
+  GstVideoFormat format = gst_video_format_from_fourcc (fourcc);
+
+  g_value_init (&fourccval, GST_TYPE_FOURCC);
+
+  for (i = 0; stride_conversions[i].format[0] != GST_VIDEO_FORMAT_UNKNOWN; i++) {
+    if (stride_conversions[i].format[from_format] == format) {
+      guint result_fourcc =
+          gst_video_format_to_fourcc (stride_conversions[i].format[to_format]);
+      gst_value_set_fourcc (&fourccval, result_fourcc);
+      gst_value_list_append_value (formats, &fourccval);
+    }
+  }
+}
+
+/**
+ * helper to add all fields, other than rowstride to @caps, copied from @s.
+ */
+static void
+add_all_fields (GstCaps * caps, const gchar * name, GstStructure * s,
+    gboolean rowstride, GstPadDirection direction)
+{
+  gint idx;
+  GstStructure *new_s = gst_structure_new (name, NULL);
+
+  if (rowstride) {
+    gst_structure_set (new_s, "rowstride", GST_TYPE_INT_RANGE, 1, G_MAXINT,
+        NULL);
+  }
+
+  idx = gst_structure_n_fields (s) - 1;
+  while (idx >= 0) {
+    const gchar *name = gst_structure_nth_field_name (s, idx);
+    const GValue *val = gst_structure_get_value (s, name);
+
+    idx--;
+
+    /* for format field, check the stride_conversions table to see what
+     * we can support:
+     */
+    if (!strcmp ("format", name)) {
+      GValue formats = { 0 };
+
+      g_value_init (&formats, GST_TYPE_LIST);
+
+      if (GST_VALUE_HOLDS_FOURCC (val)) {
+        add_all_fourcc_conversions (&formats,
+            gst_value_get_fourcc (val), direction);
+      } else if (GST_VALUE_HOLDS_LIST (val)) {
+        gint i;
+        for (i = 0; i < gst_value_list_get_size (val); i++) {
+          const GValue *list_val = gst_value_list_get_value (val, i);
+          if (GST_VALUE_HOLDS_FOURCC (list_val)) {
+            add_all_fourcc_conversions (&formats,
+                gst_value_get_fourcc (list_val), direction);
+          } else {
+            GST_WARNING ("malformed caps!!");
+            break;
+          }
+        }
+      } else {
+        GST_WARNING ("malformed caps!!");
+      }
+
+      gst_structure_set_value (new_s, "format", &formats);
+
+      continue;
+    }
+
+    /* copy over all other non-rowstride fields: */
+    if (strcmp ("rowstride", name)) {
+      gst_structure_set_value (new_s, name, val);
+    }
+  }
+
+  gst_caps_merge_structure (caps, new_s);
+}
+
+
+/**
+ * we can transform @caps to strided or non-strided caps with otherwise
+ * identical parameters
+ */
+static GstCaps *
+gst_stride_transform_transform_caps (GstBaseTransform * base,
+    GstPadDirection direction, GstCaps * caps)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (base);
+  GstCaps *ret;
+  GstStructure *s;
+
+  g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), NULL);
+
+  GST_DEBUG_OBJECT (self, "direction=%d, caps=%p", direction, caps);
+  LOG_CAPS (self, caps);
+
+  ret = gst_caps_new_empty ();
+  s = gst_caps_get_structure (caps, 0);
+
+  if (gst_structure_has_name (s, "video/x-raw-yuv") ||
+      gst_structure_has_name (s, "video/x-raw-yuv-strided")) {
+
+    add_all_fields (ret, "video/x-raw-yuv", s, FALSE, direction);
+    add_all_fields (ret, "video/x-raw-yuv-strided", s, TRUE, direction);
+
+  } else if (gst_structure_has_name (s, "video/x-raw-rgb") ||
+      gst_structure_has_name (s, "video/x-raw-rgb-strided")) {
+
+    add_all_fields (ret, "video/x-raw-rgb", s, FALSE, direction);
+    add_all_fields (ret, "video/x-raw-rgb-strided", s, TRUE, direction);
+
+  }
+
+  LOG_CAPS (self, ret);
+
+  return ret;
+}
+
+/**
+ * at this point, we have identical fourcc, width, and height for @incaps
+ * and @outcaps..  so we need to extract these to use for transforming,
+ * plus the requested rowstride of the @incaps and @outcaps
+ */
+static gboolean
+gst_stride_transform_set_caps (GstBaseTransform * base,
+    GstCaps * incaps, GstCaps * outcaps)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (base);
+  gint width, height;
+  GstVideoFormat in_format, out_format;
+  gint i;
+
+  LOG_CAPS (self, incaps);
+  LOG_CAPS (self, outcaps);
+
+  g_return_val_if_fail (gst_video_format_parse_caps_strided (incaps,
+          &in_format, &self->width, &self->height, &self->in_rowstride), FALSE);
+  g_return_val_if_fail (gst_video_format_parse_caps_strided (outcaps,
+          &out_format, &width, &height, &self->out_rowstride), FALSE);
+
+  self->conversion = NULL;
+
+  for (i = 0; stride_conversions[i].format[0] != GST_VIDEO_FORMAT_UNKNOWN; i++) {
+    if ((stride_conversions[i].format[0] == in_format) &&
+        (stride_conversions[i].format[1] == out_format)) {
+      GST_DEBUG_OBJECT (self, "found stride_conversion: %d", i);
+      self->conversion = &stride_conversions[i];
+      break;
+    }
+  }
+
+  GST_DEBUG_OBJECT (self,
+      "conversion[%d]=%p, in_rowstride=%d, out_rowstride=%d",
+      i, self->conversion, self->in_rowstride, self->out_rowstride);
+
+  g_return_val_if_fail (self->conversion, FALSE);
+  g_return_val_if_fail (self->conversion->unstridify
+      || !self->in_rowstride, FALSE);
+  g_return_val_if_fail (self->conversion->stridify
+      || !self->out_rowstride, FALSE);
+  g_return_val_if_fail (self->width == width, FALSE);
+  g_return_val_if_fail (self->height == height, FALSE);
+
+  GST_DEBUG_OBJECT (self, "caps are ok");
+
+  return TRUE;
+}
+
+static GstFlowReturn
+gst_stride_transform_transform (GstBaseTransform * base,
+    GstBuffer * inbuf, GstBuffer * outbuf)
+{
+  GstStrideTransform *self = GST_STRIDE_TRANSFORM (base);
+
+  GST_DEBUG_OBJECT (self, "inbuf=%p (size=%d), outbuf=%p (size=%d)",
+      inbuf, GST_BUFFER_SIZE (inbuf), outbuf, GST_BUFFER_SIZE (outbuf));
+
+  if (self->in_rowstride && self->out_rowstride) {
+    GST_DEBUG_OBJECT (self, "not implemented"); // TODO
+    return GST_FLOW_ERROR;
+  } else if (self->in_rowstride) {
+    return self->conversion->unstridify (self,
+        GST_BUFFER_DATA (outbuf), GST_BUFFER_DATA (inbuf));
+  } else if (self->out_rowstride) {
+    return self->conversion->stridify (self,
+        GST_BUFFER_DATA (outbuf), GST_BUFFER_DATA (inbuf));
+  }
+
+  GST_DEBUG_OBJECT (self,
+      "this shouldn't happen!  in_rowstride=%d, out_rowstride=%d",
+      self->in_rowstride, self->out_rowstride);
+
+  return GST_FLOW_ERROR;
+}
diff --git a/gst/stride/gststridetransform.h b/gst/stride/gststridetransform.h
new file mode 100644
index 0000000..bce2526
--- /dev/null
+++ b/gst/stride/gststridetransform.h
@@ -0,0 +1,92 @@
+/* GStreamer
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+ *
+ * Description: stride transform element
+ *  Created on: Jul 2, 2009
+ *      Author: Rob Clark <rob@ti.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GSTSTRIDETRANSFORM_H__
+#define __GSTSTRIDETRANSFORM_H__
+
+
+#include <gst/video/gstvideofilter.h>
+#include <gst/video/video.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_STRIDE_TRANSFORM \
+  (gst_stride_transform_get_type())
+#define GST_STRIDE_TRANSFORM(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STRIDE_TRANSFORM,GstStrideTransform))
+#define GST_STRIDE_TRANSFORM_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STRIDE_TRANSFORM,GstStrideTransformClass))
+#define GST_IS_STRIDE_TRANSFORM(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STRIDE_TRANSFORM))
+#define GST_IS_STRIDE_TRANSFORM_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STRIDE_TRANSFORM))
+
+typedef struct _GstStrideTransform GstStrideTransform;
+typedef struct _GstStrideTransformClass GstStrideTransformClass;
+
+/**
+ * stride/colorspace conversion table (used internally)
+ */
+typedef struct {
+
+  GstVideoFormat format[2];   /* in_format, out_format */
+
+  GstFlowReturn (*stridify) (GstStrideTransform *self, guchar *strided, guchar *unstrided);
+  GstFlowReturn (*unstridify) (GstStrideTransform *self, guchar *unstrided, guchar *strided);
+
+} Conversion;
+
+
+/**
+ * GstStrideTransform:
+ *
+ * Opaque datastructure.
+ */
+struct _GstStrideTransform {
+  GstVideoFilter videofilter;
+
+  /*< private >*/
+  gint width, height;
+  gint in_rowstride;
+  gint out_rowstride;
+  const Conversion *conversion;
+
+  /* for caching the tranform_size() results.. */
+  GstCaps *cached_caps[2];
+  guint cached_size[2];
+};
+
+struct _GstStrideTransformClass {
+  GstVideoFilterClass parent_class;
+};
+
+GType gst_stride_transform_get_type (void);
+
+G_END_DECLS
+
+
+#define LOG_CAPS(obj, caps)  GST_DEBUG_OBJECT (obj, "%s: %"GST_PTR_FORMAT, #caps, caps)
+
+
+#endif /* __GSTSTRIDETRANSFORM_H__ */
diff --git a/gst/stride/plugin.c b/gst/stride/plugin.c
new file mode 100644
index 0000000..7672bdc
--- /dev/null
+++ b/gst/stride/plugin.c
@@ -0,0 +1,45 @@
+/* GStreamer
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc - http://www.ti.com/
+ *
+ * Description: V4L2 sink element
+ *  Created on: Jul 30, 2009
+ *      Author: Rob Clark <rob@ti.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gststridetransform.h"
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  if (!gst_element_register (plugin, "stridetransform",
+          GST_RANK_PRIMARY, gst_stride_transform_get_type ()))
+    return FALSE;
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "stridetransform",
+    "Convert video from strided to non-strided, or between different row-strides",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
-- 
1.6.3.1

