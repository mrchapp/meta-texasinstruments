diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/Makefile.am gst-plugins-ugly-0.10.11/gst/asfdemux/Makefile.am
--- gst-plugins-ugly-0.10.9/gst/asfdemux/Makefile.am	2007-07-27 05:12:55.000000000 -0500
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/Makefile.am	2009-03-06 11:45:20.000000000 -0600
@@ -1,9 +1,11 @@
 plugin_LTLIBRARIES = libgstasf.la
 
-libgstasf_la_SOURCES = gstasfdemux.c gstasf.c asfheaders.c asfpacket.c gstrtspwms.c
+libgstasf_la_SOURCES = gstasfdemux.c gstasf.c asfheaders.c asfpacket.c gstrtpasfdepay.c gstrtspwms.c
 libgstasf_la_CFLAGS = $(GST_BASE_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
 libgstasf_la_LIBADD = $(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS)\
-		-lgstriff-@GST_MAJORMINOR@ -lgstrtsp-@GST_MAJORMINOR@ -lgstsdp-@GST_MAJORMINOR@
+		-lgstriff-@GST_MAJORMINOR@ -lgstrtsp-@GST_MAJORMINOR@ -lgstsdp-@GST_MAJORMINOR@ \
+		-lgstrtp-@GST_MAJORMINOR@
 libgstasf_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstasf_la_LIBTOOLFLAGS = --tag=disable-static
 
-noinst_HEADERS = gstasfdemux.h asfheaders.h asfpacket.h gstasfmux.h gstrtspwms.h
+noinst_HEADERS = gstasfdemux.h asfheaders.h asfpacket.h gstasfmux.h gstrtpasfdepay.h gstrtspwms.h
diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/asfpacket.c gst-plugins-ugly-0.10.11/gst/asfdemux/asfpacket.c
--- gst-plugins-ugly-0.10.9/gst/asfdemux/asfpacket.c	2007-05-04 06:04:16.000000000 -0500
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/asfpacket.c	2009-03-06 11:45:20.000000000 -0600
@@ -127,6 +127,11 @@
     GST_DEBUG_OBJECT (demux, "first ts: %" GST_TIME_FORMAT,
         GST_TIME_ARGS (payload->ts));
     demux->first_ts = payload->ts;
+    if (demux->streaming) {
+      gst_segment_set_seek (&demux->segment, demux->segment.rate,
+          GST_FORMAT_TIME, demux->segment.flags, GST_SEEK_TYPE_SET,
+          demux->first_ts, GST_SEEK_TYPE_NONE, 0, NULL);
+    }
   }
 
   /* better drop a few frames at the beginning than send bogus timestamps */
@@ -140,7 +145,8 @@
   }
 
   /* make timestamps start from 0 */
-  payload->ts -= demux->first_ts;
+  if (!demux->streaming)
+    payload->ts -= demux->first_ts;
 
   /* remove any incomplete payloads that will never be completed */
   while (stream->payloads->len > 0) {
@@ -317,6 +323,9 @@
           GST_TIME_ARGS (payload.duration));
     } else if (payload.rep_data_len != 0) {
       GST_WARNING_OBJECT (demux, "invalid replicated data length, very bad");
+      *p_data += payload_len;
+      *p_size -= payload_len;
+      return FALSE;
     }
 
     GST_LOG_OBJECT (demux, "media object offset : %u", payload.mo_offset);
diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/gstasf.c gst-plugins-ugly-0.10.11/gst/asfdemux/gstasf.c
--- gst-plugins-ugly-0.10.9/gst/asfdemux/gstasf.c	2008-08-11 16:21:43.000000000 -0500
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/gstasf.c	2009-03-06 11:45:20.000000000 -0600
@@ -27,6 +27,8 @@
 
 #include "gstasfdemux.h"
 #include "gstrtspwms.h"
+#include "gstrtpasfdepay.h"
+
 /* #include "gstasfmux.h" */
 
 static gboolean
@@ -51,6 +53,10 @@
           GST_TYPE_RTSP_WMS)) {
     return FALSE;
   }
+  if (!gst_element_register (plugin, "rtpasfdepay", GST_RANK_MARGINAL,
+          GST_TYPE_RTP_ASF_DEPAY)) {
+    return FALSE;
+  }
 /*
   if (!gst_element_register (plugin, "asfmux", GST_RANK_NONE, GST_TYPE_ASFMUX))
     return FALSE;
diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/gstasfdemux.c gst-plugins-ugly-0.10.11/gst/asfdemux/gstasfdemux.c
--- gst-plugins-ugly-0.10.9/gst/asfdemux/gstasfdemux.c	2008-08-11 16:21:43.000000000 -0500
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/gstasfdemux.c	2009-03-06 11:45:20.000000000 -0600
@@ -23,9 +23,6 @@
  * - _loop():
  *   stop if at end of segment if != end of file, ie. demux->segment.stop
  *
- * - _chain(): fix newsegment events for live streams where timestamps don't
- *   start at zero (need sample files/streams for this)
- *
  * - fix packet parsing:
  *   there's something wrong with timestamps for packets with keyframes,
  *   and durations too.
@@ -98,8 +95,6 @@
 static void gst_asf_demux_activate_ext_props_streams (GstASFDemux * demux);
 static gboolean gst_asf_demux_pull_headers (GstASFDemux * demux);
 static void gst_asf_demux_pull_indices (GstASFDemux * demux);
-static GstFlowReturn gst_asf_demux_handle_data (GstASFDemux * demux,
-    guint8 ** p_data, guint64 * p_size);
 static void gst_asf_demux_reset_stream_state_after_discont (GstASFDemux * asf);
 static gboolean
 gst_asf_demux_parse_data_object_start (GstASFDemux * demux, guint8 * data);
@@ -315,8 +310,17 @@
       }
 
       GST_OBJECT_LOCK (demux);
+      if (demux->packet_size && newsegment_start > demux->data_offset)
+        demux->packet = (newsegment_start - demux->data_offset) /
+            demux->packet_size;
+      else
+        demux->packet = 0;
+      demux->first_ts = GST_CLOCK_TIME_NONE;
+      demux->need_newsegment = TRUE;
       gst_asf_demux_reset_stream_state_after_discont (demux);
       GST_OBJECT_UNLOCK (demux);
+
+      gst_event_unref (event);
       break;
     }
     case GST_EVENT_EOS:{
@@ -333,6 +337,14 @@
       break;
     }
 
+    case GST_EVENT_FLUSH_START:
+    case GST_EVENT_FLUSH_STOP:
+      GST_OBJECT_LOCK (demux);
+      gst_asf_demux_reset_stream_state_after_discont (demux);
+      GST_OBJECT_UNLOCK (demux);
+      gst_asf_demux_send_event_unlocked (demux, event);
+      break;
+
     default:
       ret = gst_pad_event_default (pad, event);
       break;
@@ -452,6 +464,11 @@
   accurate = ((flags & GST_SEEK_FLAG_ACCURATE) == GST_SEEK_FLAG_ACCURATE);
   keyunit_sync = ((flags & GST_SEEK_FLAG_KEY_UNIT) == GST_SEEK_FLAG_KEY_UNIT);
 
+  if (demux->streaming) {
+    gst_event_ref (event);
+    return gst_pad_push_event (demux->sinkpad, event);
+  }
+
   /* unlock the streaming thread */
   if (flush) {
     gst_pad_push_event (demux->sinkpad, gst_event_new_flush_start ());
@@ -724,92 +741,6 @@
   return GST_FLOW_NOT_LINKED;
 }
 
-static GstFlowReturn
-gst_asf_demux_chain (GstPad * pad, GstBuffer * buf)
-{
-  GstFlowReturn ret = GST_FLOW_OK;
-  GstASFDemux *demux;
-
-  demux = GST_ASF_DEMUX (GST_PAD_PARENT (pad));
-
-  GST_LOG_OBJECT (demux, "buffer: size=%u, offset=%" G_GINT64_FORMAT,
-      GST_BUFFER_SIZE (buf), GST_BUFFER_OFFSET (buf));
-
-  if (GST_BUFFER_IS_DISCONT (buf))
-    gst_asf_demux_reset_stream_state_after_discont (demux);
-
-  gst_adapter_push (demux->adapter, buf);
-
-  switch (demux->state) {
-    case GST_ASF_DEMUX_STATE_HEADER:{
-      ret = gst_asf_demux_chain_headers (demux);
-      if (demux->state != GST_ASF_DEMUX_STATE_DATA)
-        break;
-      /* otherwise fall through */
-    }
-    case GST_ASF_DEMUX_STATE_DATA:{
-
-      if (demux->need_newsegment) {
-        GST_DEBUG_OBJECT (demux, "sending new-segment event from %"
-            GST_SEGMENT_FORMAT, &demux->segment);
-
-        /* FIXME: check last parameter, streams may have non-zero start */
-        gst_asf_demux_send_event_unlocked (demux,
-            gst_event_new_new_segment (FALSE, demux->segment.rate,
-                GST_FORMAT_TIME, demux->segment.start, demux->segment.stop,
-                demux->segment.start));
-
-        demux->need_newsegment = FALSE;
-        demux->segment_running = TRUE;
-      }
-
-      while (gst_adapter_available (demux->adapter) >= demux->packet_size) {
-        guint64 data_size;
-        guint8 *data;
-
-        data_size = demux->packet_size;
-        data = (guint8 *) gst_adapter_peek (demux->adapter, data_size);
-        g_assert (data != NULL);
-
-        ret = gst_asf_demux_handle_data (demux, &data, &data_size);
-
-        /* FIXME: check if this can happen, shouldn't really, should it? */
-        if (ret == ASF_FLOW_NEED_MORE_DATA) {
-          GST_DEBUG_OBJECT (demux, "not flushing, flow was need-more-data");
-
-          /* FIXME: we always know the packet size, this code is weird */
-          /* if we know the packet size and still do a
-           * short read, then something is fishy */
-/*
-          GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
-              ("Error parsing packet"),
-              ("Unexpected short read in packet at offset %" G_GINT64_FORMAT,
-                  gst_asf_demux_get_current_offset (demux, NULL)));
-          
-          ret = GST_FLOW_ERROR;
-*/
-          gst_adapter_flush (demux->adapter, demux->packet_size);
-          ret = GST_FLOW_OK;
-          break;                /* bail out */
-        } else {
-          GST_DEBUG ("flushing packet (%u bytes)", demux->packet_size);
-          gst_adapter_flush (demux->adapter, demux->packet_size);
-        }
-      }
-      break;
-    }
-    default:
-      g_assert_not_reached ();
-  }
-
-  /* FIXME: eradicate ASF_FLOW_NEED_MORE_DATA */
-
-  if (ret != GST_FLOW_OK)
-    GST_DEBUG_OBJECT (demux, "flow: %s", gst_flow_get_name (ret));
-
-  return ret;
-}
-
 static gboolean
 gst_asf_demux_pull_data (GstASFDemux * demux, guint64 offset, guint size,
     GstBuffer ** p_buf, GstFlowReturn * p_flow)
@@ -1333,7 +1264,7 @@
     if (!demux->activated_streams)
       flow = gst_asf_demux_push_complete_payloads (demux, TRUE);
 
-    if (flow != GST_FLOW_OK && flow != GST_FLOW_UNEXPECTED) {
+    if (GST_FLOW_IS_FATAL (flow) || flow == GST_FLOW_NOT_LINKED) {
       GST_DEBUG_OBJECT (demux, "pushing complete payloads failed");
       goto pause;
     }
@@ -1365,7 +1296,7 @@
     gst_pad_pause_task (demux->sinkpad);
 
     /* For the error cases (not EOS) */
-    if (flow != GST_FLOW_OK && flow != GST_FLOW_UNEXPECTED) {
+    if (GST_FLOW_IS_FATAL (flow) || flow == GST_FLOW_NOT_LINKED) {
       /* Post an error. Hopefully something else already has, but if not... */
       GST_ELEMENT_ERROR (demux, STREAM, FAILED,
           (_("Internal data stream error.")),
@@ -1393,6 +1324,64 @@
   }
 }
 
+static GstFlowReturn
+gst_asf_demux_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstASFDemux *demux;
+
+  demux = GST_ASF_DEMUX (GST_PAD_PARENT (pad));
+
+  GST_LOG_OBJECT (demux, "buffer: size=%u, offset=%" G_GINT64_FORMAT,
+      GST_BUFFER_SIZE (buf), GST_BUFFER_OFFSET (buf));
+
+  if (GST_BUFFER_IS_DISCONT (buf))
+    gst_asf_demux_reset_stream_state_after_discont (demux);
+
+  gst_adapter_push (demux->adapter, buf);
+
+  switch (demux->state) {
+    case GST_ASF_DEMUX_STATE_HEADER:{
+      ret = gst_asf_demux_chain_headers (demux);
+      if (demux->state != GST_ASF_DEMUX_STATE_DATA)
+        break;
+      /* otherwise fall through */
+    }
+    case GST_ASF_DEMUX_STATE_DATA:
+    {
+      guint64 data_size;
+
+      data_size = demux->packet_size;
+
+      while (gst_adapter_available (demux->adapter) >= data_size) {
+        GstBuffer *buf;
+
+        buf = gst_adapter_take_buffer (demux->adapter, data_size);
+
+        /* FIXME: maybe we should just skip broken packets and error out only
+         * after a few broken packets in a row? */
+        if (!gst_asf_demux_parse_packet (demux, buf)) {
+          GST_WARNING_OBJECT (demux, "Parse error");
+        }
+
+        gst_buffer_unref (buf);
+
+        ret = gst_asf_demux_push_complete_payloads (demux, FALSE);
+
+        ++demux->packet;
+      }
+      break;
+    }
+    default:
+      g_assert_not_reached ();
+  }
+
+  if (ret != GST_FLOW_OK)
+    GST_DEBUG_OBJECT (demux, "flow: %s", gst_flow_get_name (ret));
+
+  return ret;
+}
+
 static inline gboolean
 gst_asf_demux_skip_bytes (guint num_bytes, guint8 ** p_data, guint64 * p_size)
 {
@@ -1561,18 +1550,6 @@
 }
 
 static gboolean
-gst_asf_demux_get_obj_data_correction (asf_obj_data_correction * object,
-    guint8 ** p_data, guint64 * p_size)
-{
-  if (*p_size < (1 + 1))
-    return FALSE;
-
-  object->type = gst_asf_demux_get_uint8 (p_data, p_size);
-  object->cycle = gst_asf_demux_get_uint8 (p_data, p_size);
-  return TRUE;
-}
-
-static gboolean
 gst_asf_demux_get_stream_audio (asf_stream_audio * audio, guint8 ** p_data,
     guint64 * p_size)
 {
@@ -1782,8 +1759,11 @@
     s = gst_asf_demux_get_metadata_for_stream (demux, id);
     if (gst_structure_get_int (s, "AspectRatioX", &ax) &&
         gst_structure_get_int (s, "AspectRatioY", &ay)) {
-      gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
-          ax, ay, NULL);
+      /* only copy sane values */
+      if (ax > 0 && ay > 0) {
+        gst_caps_set_simple (caps, "pixel-aspect-ratio", GST_TYPE_FRACTION,
+            ax, ay, NULL);
+      }
     }
     /* remove the framerate we will guess and add it later */
     s = gst_caps_get_structure (caps, 0);
@@ -2276,12 +2256,15 @@
 
     if (data_type != ASF_DEMUX_DATA_TYPE_DWORD) {
       gst_asf_demux_skip_bytes (data_len, &data, &size);
+      g_free (name_utf8);
       continue;
     }
 
     /* read DWORD */
-    if (size < 4)
+    if (size < 4) {
+      g_free (name_utf8);
       goto not_enough_data;
+    }
 
     ival = gst_asf_demux_get_uint32 (&data, &size);
 
@@ -3238,605 +3221,6 @@
   return ret;
 }
 
-static GstFlowReturn
-gst_asf_demux_push_buffer (GstASFDemux * demux, AsfStream * stream,
-    GstBuffer * buf)
-{
-  buf = gst_buffer_make_metadata_writable (buf);
-
-  /* need to send tags? */
-  if (stream->pending_tags) {
-    GST_LOG_OBJECT (stream->pad, "tags %" GST_PTR_FORMAT, stream->pending_tags);
-    gst_element_found_tags_for_pad (GST_ELEMENT (demux), stream->pad,
-        stream->pending_tags);
-    stream->pending_tags = NULL;
-  }
-
-  /* don't set the same time stamp on multiple consecutive outgoing
-   * video buffers, set it on the first one and set NONE on the others,
-   * it's the decoder's job to fill the missing bits properly */
-  if (stream->is_video && GST_BUFFER_TIMESTAMP_IS_VALID (buf) &&
-      GST_BUFFER_TIMESTAMP (buf) == stream->last_buffer_timestamp) {
-    GST_BUFFER_TIMESTAMP (buf) = GST_CLOCK_TIME_NONE;
-  }
-
-  /* make sure segment.last_stop is continually increasing */
-  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf) &&
-      demux->segment.last_stop < (gint64) GST_BUFFER_TIMESTAMP (buf)) {
-    gst_segment_set_last_stop (&demux->segment, GST_FORMAT_TIME,
-        GST_BUFFER_TIMESTAMP (buf));
-  }
-
-  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf))
-    stream->last_buffer_timestamp = GST_BUFFER_TIMESTAMP (buf);
-
-  gst_buffer_set_caps (buf, stream->caps);
-
-  GST_LOG_OBJECT (stream->pad, "pushing buffer, ts=%" GST_TIME_FORMAT " %s",
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
-      (stream->discont) ? "discont" : "");
-
-  if (stream->discont) {
-    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
-    stream->discont = FALSE;
-  }
-
-  stream->last_flow = gst_pad_push (stream->pad, buf);
-
-  return stream->last_flow;
-}
-
-static GstFlowReturn
-gst_asf_demux_process_chunk (GstASFDemux * demux,
-    asf_packet_info * packet_info, asf_segment_info * segment_info,
-    guint8 ** p_data, guint64 * p_size)
-{
-  GstFlowReturn ret = GST_FLOW_OK;
-  AsfStream *stream;
-  GstBuffer *buffer;
-
-  stream = gst_asf_demux_get_stream (demux, segment_info->stream_number);
-  if (stream == NULL) {
-    GST_WARNING ("invalid stream number %d", segment_info->stream_number);
-    if (!gst_asf_demux_skip_bytes (segment_info->chunk_size, p_data, p_size))
-      ret = ASF_FLOW_NEED_MORE_DATA;
-    goto done;
-  }
-
-  GST_DEBUG ("Processing %s chunk of size %u (frag_offset=%d)",
-      GST_PAD_NAME (stream->pad), segment_info->chunk_size,
-      stream->frag_offset);
-
-  if (segment_info->frag_offset == 0) {
-    /* new packet */
-    stream->sequence = segment_info->sequence;
-    if (!GST_CLOCK_TIME_IS_VALID (stream->first_pts))
-      stream->first_pts = segment_info->frag_timestamp - demux->preroll;
-    demux->pts =
-        segment_info->frag_timestamp - demux->preroll - stream->first_pts;
-
-    /*
-       if (stream->is_video) {
-       GST_DEBUG ("%s: demux->pts=%lld (frag_timestamp=%ld, preroll=%lld)",
-       GST_PAD_NAME (stream->pad), demux->pts,
-       segment_info->frag_timestamp, demux->preroll);
-       }
-     */
-
-    if (!gst_asf_demux_get_buffer (&buffer, segment_info->chunk_size,
-            p_data, p_size)) {
-      return ASF_FLOW_NEED_MORE_DATA;
-    }
-
-    GST_DEBUG ("BUFFER: Copied stream to buffer %p", buffer);
-    stream->payload = buffer;
-  } else {
-    GST_DEBUG ("segment_info->sequence=%d, stream->sequence=%d,"
-        " segment_info->frag_offset=%d, stream->frag_offset=%d",
-        segment_info->sequence, stream->sequence, segment_info->frag_offset,
-        stream->frag_offset);
-
-    if (segment_info->sequence == stream->sequence &&
-        segment_info->frag_offset == stream->frag_offset) {
-      GstBuffer *new_buffer;
-
-      /* continuing packet */
-      GST_INFO ("continuation packet");
-
-      if (!gst_asf_demux_get_buffer (&buffer, segment_info->chunk_size,
-              p_data, p_size)) {
-        return ASF_FLOW_NEED_MORE_DATA;
-      }
-
-      GST_DEBUG ("copied stream to buffer %p", buffer);
-
-      new_buffer = gst_buffer_merge (stream->payload, buffer);
-      GST_DEBUG_OBJECT (demux,
-          "BUFFER: Merged new_buffer (%p - %d) from stream->payload (%p - %d)"
-          " and buffer (%p - %d)", new_buffer,
-          GST_MINI_OBJECT_REFCOUNT_VALUE (new_buffer), stream->payload,
-          GST_MINI_OBJECT_REFCOUNT_VALUE (stream->payload), buffer,
-          GST_MINI_OBJECT_REFCOUNT_VALUE (buffer));
-      gst_buffer_unref (stream->payload);
-      gst_buffer_unref (buffer);
-      stream->payload = new_buffer;
-    } else {
-      /* cannot continue current packet: free it */
-      if (stream->frag_offset != 0) {
-        /* cannot create new packet */
-        GST_DEBUG ("BUFFER: Freeing stream->payload (%p)", stream->payload);
-        gst_buffer_unref (stream->payload);
-#if 0
-        /* FIXME: is this right/needed? we already do that below, no? */
-        packet_info->size_left -= segment_info->chunk_size;
-#endif
-        stream->frag_offset = 0;
-      }
-      demux->pts =
-          segment_info->frag_timestamp - demux->preroll - stream->first_pts;
-
-      /*
-         if (stream->is_video) {
-         GST_DEBUG ("%s: demux->pts=%lld (frag_timestamp=%ld, preroll=%lld)",
-         GST_PAD_NAME (stream->pad), demux->pts,
-         segment_info->frag_timestamp, demux->preroll);
-         }
-       */
-
-      goto done;
-#if 0
-      /* FIXME: where did this come from / fit in ? */
-      return TRUE;
-      else {
-        /* create new packet */
-        stream->sequence = segment_info->sequence;
-      }
-#endif
-    }
-  }
-
-  stream->frag_offset += segment_info->chunk_size;
-
-  GST_DEBUG ("frag_offset = %d  segment_size = %d ", stream->frag_offset,
-      segment_info->segment_size);
-
-  if (stream->frag_offset < segment_info->segment_size) {
-    /* We don't have the whole packet yet */
-  } else {
-    /* We have the whole packet now so we should push the packet to
-       the src pad now. First though we should check if we need to do
-       descrambling */
-    if (demux->span > 1) {
-      gst_asf_demux_descramble_buffer (demux, stream, &stream->payload);
-    }
-
-    if (stream->is_video) {
-      GST_DEBUG ("%s: demux->pts=%lld=%" GST_TIME_FORMAT
-          ", stream->last_pts=%lld=%" GST_TIME_FORMAT,
-          GST_PAD_NAME (stream->pad), demux->pts,
-          GST_TIME_ARGS (GST_MSECOND * demux->pts), stream->last_pts,
-          GST_TIME_ARGS (GST_MSECOND * stream->last_pts));
-    }
-
-    /* FIXME: last_pts is not a GstClockTime and not in nanoseconds, so
-     * this is not really 100% right ... */
-    if (demux->pts >= stream->last_pts ||
-        !GST_CLOCK_TIME_IS_VALID (stream->last_pts)) {
-      stream->last_pts = demux->pts;
-    }
-
-    GST_BUFFER_TIMESTAMP (stream->payload) = GST_MSECOND * stream->last_pts;
-
-    GST_DEBUG ("sending stream %d of size %d, ts=%" GST_TIME_FORMAT,
-        stream->id, segment_info->chunk_size,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (stream->payload)));
-
-    if (!stream->fps_known) {
-      if (!stream->cache) {
-        stream->cache = stream->payload;
-      } else {
-        gdouble fps;
-        gint64 diff;
-        gint num, denom;
-
-        /* why is all this needed anyway? (tpm) */
-        diff = GST_BUFFER_TIMESTAMP (stream->payload) -
-            GST_BUFFER_TIMESTAMP (stream->cache);
-
-        fps = (gdouble) GST_SECOND / diff;
-
-        /* artificial cap */
-        if (fps >= 50.0) {
-          num = 50;
-          denom = 1;
-        } else if (fps <= 5.0) {
-          num = 5;
-          denom = 1;
-        } else {
-          /* crack alert */
-          num = (gint) GST_SECOND;
-          while (diff > G_MAXINT) {
-            num = num >> 1;
-            diff = diff >> 1;
-          }
-          denom = (gint) diff;
-        }
-        stream->fps_known = TRUE;
-        stream->caps = gst_caps_make_writable (stream->caps);
-        gst_caps_set_simple (stream->caps,
-            "framerate", GST_TYPE_FRACTION, num, denom, NULL);
-        GST_DEBUG ("set up stream with fps %d/%d", num, denom);
-        gst_pad_use_fixed_caps (stream->pad);
-        gst_pad_set_caps (stream->pad, stream->caps);
-
-        ret = gst_asf_demux_push_buffer (demux, stream, stream->cache);
-        stream->cache = NULL;
-
-        ret = gst_asf_demux_push_buffer (demux, stream, stream->payload);
-        stream->payload = NULL;
-      }
-    } else {
-      ret = gst_asf_demux_push_buffer (demux, stream, stream->payload);
-      stream->payload = NULL;
-    }
-
-    stream->frag_offset = 0;
-  }
-
-done:
-
-  packet_info->size_left -= segment_info->chunk_size;
-
-  return ret;
-}
-
-static GstFlowReturn
-gst_asf_demux_process_segment (GstASFDemux * demux,
-    asf_packet_info * packet_info, guint8 ** p_data, guint64 * p_size)
-{
-  GstFlowReturn ret = GST_FLOW_OK;
-  asf_segment_info segment_info;
-  gboolean has_key_frame;
-  guint64 start_size;
-  guint32 replic_size;
-  guint32 time_start;
-  guint32 frag_size;
-  guint32 rsize;
-  guint8 time_delta;
-  guint8 byte;
-
-  start_size = *p_size;
-
-  if (*p_size < 1)
-    return ASF_FLOW_NEED_MORE_DATA;
-
-  byte = gst_asf_demux_get_uint8 (p_data, p_size);
-  segment_info.stream_number = byte & 0x7f;
-  has_key_frame = ((byte & 0x80) == 0x80);      /* FIXME: use this somewhere? */
-
-  GST_INFO ("processing segment for stream %u%s", segment_info.stream_number,
-      (has_key_frame) ? " (has keyframe)" : "");
-
-  /* FIXME: check (doesn't work) */
-#if 0
-  {
-    AsfStream *stream;
-
-    stream = gst_asf_demux_get_stream (demux, segment_info.stream_number);
-    if (stream && stream->last_pts == GST_CLOCK_TIME_NONE &&
-        stream->is_video && !has_key_frame) {
-      g_print ("skipping segment, waiting for a key unit\n");
-      if (!gst_asf_demux_skip_bytes (segment_info.segment_size - 1, p_data,
-              p_size))
-        return ASF_FLOW_NEED_MORE_DATA;
-      packet_info->size_left -= segment_info.segment_size;
-      return GST_FLOW_OK;
-    }
-  }
-#endif
-
-  {
-    const guint lengths[4] = { 0, 1, 2, 4 };
-    guint needed;
-
-    needed = lengths[packet_info->seqtype]
-        + lengths[packet_info->fragoffsettype]
-        + lengths[packet_info->replicsizetype];
-
-    if (*p_size < needed)
-      return ASF_FLOW_NEED_MORE_DATA;
-  }
-
-  segment_info.sequence =
-      gst_asf_demux_get_var_length (packet_info->seqtype, p_data, p_size);
-  segment_info.frag_offset =
-      gst_asf_demux_get_var_length (packet_info->fragoffsettype, p_data,
-      p_size);
-  replic_size =
-      gst_asf_demux_get_var_length (packet_info->replicsizetype, p_data,
-      p_size);
-
-  GST_DEBUG ("sequence=%u, frag_offset=%u, replic_size=%u",
-      segment_info.sequence, segment_info.frag_offset, replic_size);
-
-  if (replic_size > 1) {
-    segment_info.compressed = FALSE;
-
-    /* It's uncompressed with replic data */
-    if (*p_size < (4 + 4))
-      goto short_repdata;
-
-    segment_info.segment_size = gst_asf_demux_get_uint32 (p_data, p_size);
-    segment_info.frag_timestamp = gst_asf_demux_get_uint32 (p_data, p_size);
-
-    GST_LOG ("frag_timestamp: %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (segment_info.frag_timestamp * GST_MSECOND));
-
-    if (replic_size > 8) {
-      if (!gst_asf_demux_skip_bytes ((replic_size - 8), p_data, p_size))
-        return ASF_FLOW_NEED_MORE_DATA;
-    }
-  } else if (replic_size == 1) {
-    /* It's compressed */
-    segment_info.compressed = TRUE;
-    if (*p_size < 1)
-      return ASF_FLOW_NEED_MORE_DATA;
-    time_delta = gst_asf_demux_get_uint8 (p_data, p_size);
-    GST_DEBUG ("time_delta = %u", time_delta);
-
-    time_start = segment_info.frag_offset;
-    segment_info.frag_offset = 0;
-    segment_info.frag_timestamp = time_start;   /* was: demux->timestamp */
-  } else {
-    segment_info.compressed = FALSE;
-
-    time_start = segment_info.frag_offset;
-    segment_info.frag_offset = 0;
-    segment_info.frag_timestamp = time_start;   /* was: demux->timestamp */
-  }
-
-  GST_DEBUG ("multiple = %u, compressed = %u",
-      packet_info->multiple, segment_info.compressed);
-
-  if (packet_info->multiple) {
-    const guint lengths[4] = { 0, 1, 2, 4 };
-
-    if (*p_size < lengths[packet_info->segsizetype])
-      return ASF_FLOW_NEED_MORE_DATA;
-
-    frag_size = gst_asf_demux_get_var_length (packet_info->segsizetype,
-        p_data, p_size);
-  } else {
-    frag_size = packet_info->size_left - (start_size - *p_size);
-  }
-
-  rsize = start_size - *p_size;
-
-  packet_info->size_left -= rsize;
-
-  GST_DEBUG ("size left = %u, frag size = %u, rsize = %u",
-      packet_info->size_left, frag_size, rsize);
-
-  if (segment_info.compressed) {
-    while (frag_size > 0) {
-      if (*p_size < 1)
-        return ASF_FLOW_NEED_MORE_DATA;
-      byte = gst_asf_demux_get_uint8 (p_data, p_size);
-      packet_info->size_left--;
-      segment_info.chunk_size = byte;
-      segment_info.segment_size = segment_info.chunk_size;
-
-      if (segment_info.chunk_size > packet_info->size_left) {
-        return ASF_FLOW_NEED_MORE_DATA;
-        /* or is this an error?
-         *   GST_ELEMENT_ERROR (demux, STREAM, DEMUX, (NULL),
-         *        ("Payload chunk overruns packet size."));
-         *    return GST_FLOW_ERROR; */
-      }
-
-      ret = gst_asf_demux_process_chunk (demux, packet_info, &segment_info,
-          p_data, p_size);
-
-      if (ret != GST_FLOW_OK)
-        break;
-
-      if (segment_info.chunk_size < frag_size)
-        frag_size -= segment_info.chunk_size + 1;
-      else {
-/*
-        GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
-            ("Invalid data in stream"),
-            ("Invalid fragment size indicator in segment"));
-        ret = GST_FLOW_ERROR;
-*/
-        return ASF_FLOW_NEED_MORE_DATA;
-      }
-    }
-  } else {
-    segment_info.chunk_size = frag_size;
-    ret = gst_asf_demux_process_chunk (demux, packet_info, &segment_info,
-        p_data, p_size);
-  }
-
-  return ret;
-
-/* ERRORS */
-short_repdata:
-  {
-    if (replic_size < 8) {
-      GST_ELEMENT_ERROR (demux, STREAM, DEMUX, (NULL),
-          ("payload has replicated data, but size is less than 8"));
-    } else {
-      GST_ELEMENT_ERROR (demux, STREAM, DEMUX, (NULL),
-          ("payload has %u bytes of replicated data, but size is only %u",
-              replic_size, (guint) * p_size));
-    }
-    return GST_FLOW_ERROR;
-  }
-}
-
-static GstFlowReturn
-gst_asf_demux_handle_data (GstASFDemux * demux, guint8 ** p_data,
-    guint64 * p_size)
-{
-  asf_packet_info packet_info;
-  gboolean correction;
-  guint64 start_size;
-  guint32 sequence;
-  guint32 packet_length;
-  guint32 rsize;
-  guint16 duration;
-  guint8 num_segments;
-  guint8 segment;
-  guint8 flags;
-  guint8 property;
-
-  start_size = *p_size;
-
-  GST_LOG ("processing packet %" G_GUINT64_FORMAT "/%" G_GUINT64_FORMAT,
-      demux->packet + 1, demux->num_packets);
-
-  if (demux->num_packets > 0 && demux->packet >= demux->num_packets) {
-    GST_LOG_OBJECT (demux, "reached EOS");
-    return GST_FLOW_UNEXPECTED;
-  }
-
-  ++demux->packet;
-
-  if (*p_size < 1) {
-    GST_WARNING ("unexpected end of data");     /* unexpected, why? */
-    return ASF_FLOW_NEED_MORE_DATA;
-  }
-
-  correction = ((gst_asf_demux_get_uint8 (p_data, p_size) & 0x80) == 0x80);
-
-  /* Uses error correction? */
-  if (correction) {
-    asf_obj_data_correction corr_obj;
-
-    GST_DEBUG ("data has error correction");
-    if (!gst_asf_demux_get_obj_data_correction (&corr_obj, p_data, p_size)) {
-      GST_WARNING ("unexpected end of data");
-      return ASF_FLOW_NEED_MORE_DATA;
-    }
-  }
-
-  /* Read the packet flags */
-  if (*p_size < (1 + 1)) {
-    GST_WARNING ("unexpected end of data");
-    return ASF_FLOW_NEED_MORE_DATA;
-  }
-  flags = gst_asf_demux_get_uint8 (p_data, p_size);
-  property = gst_asf_demux_get_uint8 (p_data, p_size);
-
-  packet_info.multiple = ((flags & 0x01) == 0x01);
-
-  {
-    const guint lengths[4] = { 0, 1, 2, 4 };
-    guint needed;
-
-    needed = lengths[(flags >> 5) & 0x03]
-        + lengths[(flags >> 3) & 0x03]
-        + lengths[(flags >> 1) & 0x03];
-
-    if (*p_size < needed)
-      return ASF_FLOW_NEED_MORE_DATA;
-  }
-
-  packet_length =
-      gst_asf_demux_get_var_length ((flags >> 5) & 0x03, p_data, p_size);
-
-  sequence = gst_asf_demux_get_var_length ((flags >> 1) & 0x03, p_data, p_size);
-
-  packet_info.padsize =
-      gst_asf_demux_get_var_length ((flags >> 3) & 0x03, p_data, p_size);
-
-  if (packet_length == 0)
-    packet_length = demux->packet_size;
-
-  GST_DEBUG ("multiple = %u, sequence = %u, padsize = %u, "
-      "packet length = %u", packet_info.multiple, sequence,
-      packet_info.padsize, packet_length);
-
-  /* Read the property flags */
-  packet_info.replicsizetype = property & 0x03;
-  packet_info.fragoffsettype = (property >> 2) & 0x03;
-  packet_info.seqtype = (property >> 4) & 0x03;
-
-  if (*p_size < (4 + 2)) {
-    GST_WARNING ("unexpected end of data");
-    return ASF_FLOW_NEED_MORE_DATA;
-  }
-
-  /* FIXME: isn't this the send time, ie. not the presentation time? (tpm) */
-  demux->timestamp = gst_asf_demux_get_uint32 (p_data, p_size);
-  duration = gst_asf_demux_get_uint16 (p_data, p_size);
-
-  GST_DEBUG ("timestamp = %" GST_TIME_FORMAT ", duration = %" GST_TIME_FORMAT,
-      GST_TIME_ARGS ((gint64) demux->timestamp * GST_MSECOND),
-      GST_TIME_ARGS ((gint64) duration * GST_MSECOND));
-
-  /* Are there multiple payloads? */
-  if (packet_info.multiple) {
-    guint8 multi_flags;
-
-    if (*p_size < 1)
-      return ASF_FLOW_NEED_MORE_DATA;
-
-    multi_flags = gst_asf_demux_get_uint8 (p_data, p_size);
-    packet_info.segsizetype = (multi_flags >> 6) & 0x03;
-    num_segments = multi_flags & 0x3f;
-  } else {
-    packet_info.segsizetype = 2;
-    num_segments = 1;
-  }
-
-  rsize = start_size - *p_size;
-
-  packet_info.size_left = packet_length - packet_info.padsize - rsize;
-
-  GST_DEBUG ("rsize: %u, size left: %u", rsize, packet_info.size_left);
-
-  for (segment = 0; segment < num_segments; ++segment) {
-    GstFlowReturn ret;
-
-    ret = gst_asf_demux_process_segment (demux, &packet_info, p_data, p_size);
-    if (ret != GST_FLOW_OK) {
-      GST_DEBUG ("process_segment %u returned %s", segment,
-          gst_asf_get_flow_name (ret));
-    }
-  }
-
-  /* Skip the padding */
-  if (packet_info.padsize > 0) {
-    if (*p_size < packet_info.padsize) {
-      GST_WARNING ("unexpected end of data");
-      return ASF_FLOW_NEED_MORE_DATA;
-    }
-
-    if (!gst_asf_demux_skip_bytes (packet_info.padsize, p_data, p_size))
-      return ASF_FLOW_NEED_MORE_DATA;
-  }
-
-  GST_DEBUG ("remaining size left: %u", packet_info.size_left);
-
-  /* FIXME: this doesn't really make sense, does it? if we don't have enough
-   * bytes left to skip the stuff at the end and we've already sent out
-   * buffers, just returning NEED_MORE_DATA isn't really right. Should we
-   * just throw an error in that case (can it happen with a non-broken
-   * stream?) */
-  if (packet_info.size_left > 0) {
-    if (!gst_asf_demux_skip_bytes (packet_info.size_left, p_data, p_size)) {
-      GST_WARNING
-          ("unexpected end of data, *p_size=%lld,packet_info.size_left=%u",
-          *p_size, packet_info.size_left);
-      return ASF_FLOW_NEED_MORE_DATA;
-    }
-  }
-
-  return gst_asf_demux_aggregate_flow_return (demux);
-}
-
 static const GstQueryType *
 gst_asf_demux_get_src_query_types (GstPad * pad)
 {
diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/gstrtpasfdepay.c gst-plugins-ugly-0.10.11/gst/asfdemux/gstrtpasfdepay.c
--- gst-plugins-ugly-0.10.9/gst/asfdemux/gstrtpasfdepay.c	1969-12-31 18:00:00.000000000 -0600
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/gstrtpasfdepay.c	2009-03-06 11:45:20.000000000 -0600
@@ -0,0 +1,383 @@
+/* GStreamer RTP ASF depayloader
+ * Copyright (C) 2006 Tim-Philipp Müller  <tim centricular net>
+ *               2009 Wim Taymans  <wim.taymans@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "gstrtpasfdepay.h"
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include <string.h>
+#include <stdlib.h>
+
+GST_DEBUG_CATEGORY_STATIC (rtpasfdepayload_debug);
+#define GST_CAT_DEFAULT rtpasfdepayload_debug
+
+static const GstElementDetails rtp_asf_depay_details =
+GST_ELEMENT_DETAILS ("RTP ASF packet depayloader",
+    "Codec/Depayloader/Network",
+    "Extracts ASF streams from RTP",
+    "Tim-Philipp Müller <tim centricular net>, "
+    "Wim Taymans <wim.taymans@gmail.com>");
+
+static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-ms-asf")
+    );
+
+/* Other parameters: config, maxps */
+#define SINK_CAPS \
+  "application/x-rtp, "                                          \
+  "media = (string) { \"application\", \"video\", \"audio\" }, " \
+  "clock-rate = (int) [1, MAX ], "                               \
+  "encoding-name = (string) \"X-ASF-PF\""
+
+static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (SINK_CAPS)
+    );
+
+GST_BOILERPLATE (GstRtpAsfDepay, gst_rtp_asf_depay, GstBaseRTPDepayload,
+    GST_TYPE_BASE_RTP_DEPAYLOAD);
+
+static void gst_rtp_asf_depay_finalize (GObject * object);
+
+static GstStateChangeReturn gst_rtp_asf_depay_change_state (GstElement *
+    element, GstStateChange transition);
+
+static gboolean gst_rtp_asf_depay_setcaps (GstBaseRTPDepayload * depay,
+    GstCaps * caps);
+static GstBuffer *gst_rtp_asf_depay_process (GstBaseRTPDepayload * basedepay,
+    GstBuffer * buf);
+
+static void
+gst_rtp_asf_depay_base_init (gpointer klass)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&src_factory));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_factory));
+
+  gst_element_class_set_details (element_class, &rtp_asf_depay_details);
+}
+
+static void
+gst_rtp_asf_depay_class_init (GstRtpAsfDepayClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseRTPDepayloadClass *gstbasertpdepayload_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+  gstbasertpdepayload_class = (GstBaseRTPDepayloadClass *) klass;
+
+  gobject_class->finalize = gst_rtp_asf_depay_finalize;
+
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_rtp_asf_depay_change_state);
+
+  gstbasertpdepayload_class->set_caps =
+      GST_DEBUG_FUNCPTR (gst_rtp_asf_depay_setcaps);
+  gstbasertpdepayload_class->process =
+      GST_DEBUG_FUNCPTR (gst_rtp_asf_depay_process);
+
+  GST_DEBUG_CATEGORY_INIT (rtpasfdepayload_debug, "rtpasfdepayload", 0,
+      "RTP asf depayloader element");
+}
+
+static void
+gst_rtp_asf_depay_init (GstRtpAsfDepay * depay, GstRtpAsfDepayClass * klass)
+{
+  depay->adapter = gst_adapter_new ();
+}
+
+static void
+gst_rtp_asf_depay_finalize (GObject * object)
+{
+  GstRtpAsfDepay *depay;
+
+  depay = GST_RTP_ASF_DEPAY (object);
+
+  g_object_unref (depay->adapter);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static const guint8 asf_marker[16] = { 0x30, 0x26, 0xb2, 0x75, 0x8e, 0x66,
+  0xcf, 0x11, 0xa6, 0xd9, 0x00, 0xaa, 0x00, 0x62, 0xce, 0x6c
+};
+
+static gboolean
+gst_rtp_asf_depay_setcaps (GstBaseRTPDepayload * depayload, GstCaps * caps)
+{
+  GstRtpAsfDepay *depay;
+  GstStructure *s;
+  const gchar *config_str, *ps_string;
+  GstBuffer *buf;
+  GstCaps *src_caps;
+  guint8 *headers;
+  gsize headers_len;
+  gint clock_rate;
+
+  depay = GST_RTP_ASF_DEPAY (depayload);
+
+  s = gst_caps_get_structure (caps, 0);
+
+  if (!gst_structure_get_int (s, "clock-rate", &clock_rate) || clock_rate < 0)
+    clock_rate = 1000;
+  depayload->clock_rate = clock_rate;
+
+  /* config contains the asf headers in base64 coding */
+  config_str = gst_structure_get_string (s, "config");
+  if (config_str == NULL || *config_str == '\0')
+    goto no_config;
+
+  ps_string = gst_structure_get_string (s, "maxps");
+  if (ps_string == NULL || *ps_string == '\0')
+    goto no_packetsize;
+
+  depay->packet_size = atoi (ps_string);
+  if (depay->packet_size <= 16)
+    goto invalid_packetsize;
+
+  headers = (guint8 *) g_base64_decode (config_str, &headers_len);
+
+  if (headers == NULL || headers_len < 16
+      || memcmp (headers, asf_marker, 16) != 0)
+    goto invalid_headers;
+
+  src_caps = gst_caps_new_simple ("video/x-ms-asf", NULL);
+  gst_pad_set_caps (depayload->srcpad, src_caps);
+
+  buf = gst_buffer_new ();
+  GST_BUFFER_DATA (buf) = headers;
+  GST_BUFFER_MALLOCDATA (buf) = headers;
+  GST_BUFFER_SIZE (buf) = headers_len;
+  gst_buffer_set_caps (buf, src_caps);
+  gst_caps_unref (src_caps);
+
+  gst_base_rtp_depayload_push (depayload, buf);
+
+  return TRUE;
+
+  /* ERRORS */
+no_config:
+  {
+    GST_WARNING_OBJECT (depay, "caps without 'config' field with asf headers");
+    return FALSE;
+  }
+no_packetsize:
+  {
+    GST_WARNING_OBJECT (depay, "caps without 'maxps' (packet size) field");
+    return FALSE;
+  }
+invalid_packetsize:
+  {
+    GST_WARNING_OBJECT (depay, "packet size %u invalid", depay->packet_size);
+    return FALSE;
+  }
+invalid_headers:
+  {
+    GST_WARNING_OBJECT (depay, "headers don't look like valid ASF headers");
+    g_free (headers);
+    return FALSE;
+  }
+}
+
+/* Docs: 'RTSP Protocol PDF' document from http://sdp.ppona.com/ (page 8) */
+
+static GstBuffer *
+gst_rtp_asf_depay_process (GstBaseRTPDepayload * depayload, GstBuffer * buf)
+{
+  GstRtpAsfDepay *depay;
+  const guint8 *payload;
+  GstBuffer *outbuf;
+  gboolean S, L, R, D, I;
+  guint payload_len, hdr_len, offset;
+  guint len_offs;
+  GstClockTime timestamp;
+
+  depay = GST_RTP_ASF_DEPAY (depayload);
+
+  /* flush remaining data on discont */
+  if (GST_BUFFER_IS_DISCONT (buf)) {
+    gst_adapter_clear (depay->adapter);
+    depay->wait_start = TRUE;
+    depay->discont = TRUE;
+  }
+
+  timestamp = GST_BUFFER_TIMESTAMP (buf);
+
+  payload_len = gst_rtp_buffer_get_payload_len (buf);
+  payload = gst_rtp_buffer_get_payload (buf);
+  offset = 0;
+
+  GST_LOG_OBJECT (depay, "got payload len of %u", payload_len);
+
+  do {
+    guint packet_len;
+
+    /* packet header is at least 4 bytes */
+    if (payload_len < 4)
+      goto too_small;
+
+    /*                      1                   2                   3
+     *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * |S|L|R|D|I|RES  | Length/Offset                                 |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * | Relative Timestamp (optional)                                 |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * | Duration (optional)                                           |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     * | LocationId (optional)                                         |
+     * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+     *
+     * S: packet contains a keyframe.
+     * L: Length or offset present.
+     * R: relative timestamp present
+     * R: duration present
+     * I: locationid present
+     */
+
+    S = ((payload[0] & 0x80) != 0);
+    L = ((payload[0] & 0x40) != 0);
+    R = ((payload[0] & 0x20) != 0);
+    D = ((payload[0] & 0x10) != 0);
+    I = ((payload[0] & 0x08) != 0);
+
+    hdr_len = 4;
+
+    len_offs = (payload[1] << 16) | (payload[2] << 8) | payload[3];
+
+    if (R)
+      hdr_len += 4;
+    if (D)
+      hdr_len += 4;
+    if (I)
+      hdr_len += 4;
+
+    GST_LOG_OBJECT (depay, "S %d, L %d, R %d, D %d, I %d", S, L, R, D, I);
+
+    if (payload_len < hdr_len)
+      goto too_small;
+
+    /* skip headers */
+    payload_len -= hdr_len;
+    payload += hdr_len;
+    offset += hdr_len;
+
+    if (L) {
+      /* L bit set, len contains the length of the packet */
+      packet_len = len_offs;
+    } else {
+      packet_len = 0;
+      /* else it contains an offset which we don't handle yet */
+      g_assert_not_reached ();
+    }
+
+    if (packet_len > payload_len)
+      packet_len = payload_len;
+
+    GST_LOG_OBJECT (depay, "packet len %u, payload len %u", packet_len,
+        payload_len);
+
+    if (packet_len >= depay->packet_size) {
+      GST_LOG_OBJECT (depay, "creating subbuffer");
+      outbuf = gst_rtp_buffer_get_payload_subbuffer (buf, offset, packet_len);
+    } else {
+      GST_LOG_OBJECT (depay, "padding buffer");
+      /* we need to pad with zeroes to packet_size if it's smaller */
+      outbuf = gst_buffer_new_and_alloc (depay->packet_size);
+      memcpy (GST_BUFFER_DATA (outbuf), payload, packet_len);
+      memset (GST_BUFFER_DATA (outbuf) + packet_len, 0,
+          depay->packet_size - packet_len);
+    }
+
+    gst_buffer_set_caps (outbuf, GST_PAD_CAPS (depayload->srcpad));
+
+    if (S)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DELTA_UNIT);
+
+    if (depay->discont) {
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
+      depay->discont = FALSE;
+    }
+
+    GST_BUFFER_TIMESTAMP (outbuf) = timestamp;
+
+    gst_base_rtp_depayload_push (depayload, outbuf);
+
+    /* only apply the timestamp to the first buffer of this packet */
+    timestamp = -1;
+
+    /* skip packet data */
+    payload += packet_len;
+    offset += packet_len;
+    payload_len -= packet_len;
+  } while (payload_len > 0);
+
+  return NULL;
+
+/* ERRORS */
+too_small:
+  {
+    GST_WARNING_OBJECT (depayload, "Payload too small, expected at least 4 "
+        "bytes for header, but got only %d bytes", payload_len);
+    return NULL;
+  }
+}
+
+static GstStateChangeReturn
+gst_rtp_asf_depay_change_state (GstElement * element, GstStateChange trans)
+{
+  GstStateChangeReturn ret;
+  GstRtpAsfDepay *depay;
+
+  depay = GST_RTP_ASF_DEPAY (element);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_adapter_clear (depay->adapter);
+      depay->wait_start = TRUE;
+      depay->discont = TRUE;
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_adapter_clear (depay->adapter);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
diff -Naur gst-plugins-ugly-0.10.9/gst/asfdemux/gstrtpasfdepay.h gst-plugins-ugly-0.10.11/gst/asfdemux/gstrtpasfdepay.h
--- gst-plugins-ugly-0.10.9/gst/asfdemux/gstrtpasfdepay.h	1969-12-31 18:00:00.000000000 -0600
+++ gst-plugins-ugly-0.10.11/gst/asfdemux/gstrtpasfdepay.h	2009-03-06 11:45:20.000000000 -0600
@@ -0,0 +1,65 @@
+/* GStreamer RTP ASF depayloader
+ * Copyright (C) 2006 Tim-Philipp Müller  <tim centricular net>
+ *               2009 Wim Taymans  <wim.taymans@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTP_ASF_DEPAY_H__
+#define __GST_RTP_ASF_DEPAY_H__
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+
+#include <gst/rtp/gstbasertpdepayload.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_ASF_DEPAY \
+  (gst_rtp_asf_depay_get_type())
+#define GST_RTP_ASF_DEPAY(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ASF_DEPAY,GstRtpAsfDepay))
+#define GST_RTP_ASF_DEPAY_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ASF_DEPAY,GstRtpAsfDepayClass))
+#define GST_IS_RTP_ASF_DEPAY(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ASF_DEPAY))
+#define GST_IS_RTP_ASF_DEPAY_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ASF_DEPAY))
+
+typedef struct _GstRtpAsfDepay      GstRtpAsfDepay;
+typedef struct _GstRtpAsfDepayClass GstRtpAsfDepayClass;
+
+struct _GstRtpAsfDepay
+{
+  GstBaseRTPDepayload depayload;
+
+  guint packet_size;
+
+  GstAdapter *adapter;
+  gboolean    discont;
+  gboolean    wait_start;
+};
+
+struct _GstRtpAsfDepayClass
+{
+  GstBaseRTPDepayloadClass depayload_class;
+};
+
+GType    gst_rtp_asf_depay_get_type (void);
+
+G_END_DECLS
+
+#endif /* __GST_RTP_ASF_DEPAY_H__ */
